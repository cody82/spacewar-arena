<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Tao.Ode</name>
    </assembly>
    <members>
        <member name="T:Tao.Ode.Ode">
            <summary>
                Open Dynamics Engine 0.5 (ODE - http://ode.org) bindings for .NET.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.ODE_NATIVE_LIBRARY">
            <summary>
            Specifies the ODE native library used in the bindings
            </summary>
            <remarks>
            The Windows dll is specified here universally - note that
            under Mono the non-windows native library can be mapped using
            the ".config" file mechanism.  Kudos to the Mono team for this
            simple yet elegant solution.
            </remarks>
        </member>
        <member name="F:Tao.Ode.Ode.CALLING_CONVENTION">
            <summary>
                Specifies the calling convention used for the binding.
            </summary>
            <remarks>
                Specifies <see cref="F:System.Runtime.InteropServices.CallingConvention.Winapi"/>.
            </remarks>
        </member>
        <member name="F:Tao.Ode.Ode.dInfinity">
            <summary>
            Infinity.
            
            The maximum value of the current data type for dReal.
            
            </summary>
            <remarks>
            dReal can be System.Single or System.Double, based on the
            multiple precision levels possible with the ODE library.
            </remarks>
        </member>
        <member name="F:Tao.Ode.Ode.dMaxUserClasses">
            <summary>the maximum number of user classes that are supported</summary>
        </member>
        <member name="M:Tao.Ode.Ode.#ctor">
            <summary>
                Empty constructor - prevents instantiation.
            </summary>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldCreate">
            <summary>
            Create a new, empty world and return its ID number.
            </summary>
            <remarks>
            The world object is a container for rigid bodies and joints.
            Objects in different worlds can not interact, for example rigid bodies from two different worlds can not collide.
            All the objects in a world exist at the same point in time, thus one reason to use separate worlds is to simulate
            systems at different rates.
                        Most applications will only need one world.
            </remarks>
            <returns>A dWorldID</returns>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldDestroy(System.IntPtr)">
            <summary>
            Destroy a world and everything in it.
            This includes all bodies, and all joints that are not part of a joint group.
            Joints that are part of a joint group will be deactivated, and can be destroyed by calling, for example,
            dJointGroupEmpty.
            </summary>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetGravity(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the world's global gravity vector.
            The units are m/s/s, so Earth's gravity vector would be (0,0,-9.81), assuming that +z is up.
            The default is no gravity, i.e. (0,0,0).
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetGravity(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the world's global gravity vector.
            The units are m/s/s.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="gravity">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetERP(System.IntPtr,System.Single)">
            <summary>
            Set the global ERP value, which controls how much error correction is performed in each time step.
            Typical values are in the range 0.1--0.8. The default is 0.2.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="erp">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetERP(System.IntPtr)">
            <summary>
            Get the global ERP value, which controls how much error correction is performed in each time step.
            Typical values are in the range 0.1--0.8. The default is 0.2.
            </summary>
            <returns>A dReal</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetCFM(System.IntPtr,System.Single)">
            <summary>
            Set the global CFM (constraint force mixing) value.
            Typical values are in the range 10-9 -- 1.
            The default is 10-5 if single precision is being used, or 10-10 if double precision is being used.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="cfm">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetCFM(System.IntPtr)">
            <summary>
            Get the global CFM (constraint force mixing) value.
            Typical values are in the range 10-9 -- 1.
            The default is 10-5 if single precision is being used, or 10-10 if double precision is being used.
            </summary>
            <returns>A dReal</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldImpulseToForce(System.IntPtr,System.Single,System.Single,System.Single,System.Single,Tao.Ode.Ode.dVector3@)">
            <summary>
            Convert linear/angular impulse to a rigid body to a force/torque vector.
                        If you want to apply a linear or angular impulse to a rigid body, instead of a force or a torque,
            then you can use this function to convert the desired impulse into a force/torque vector before
            calling the dBodyAdd... function.
                        This function is given the desired impulse as (ix,iy,iz) and puts the force vector in force.
                        The current algorithm simply scales the impulse by 1/stepsize, where stepsize is the step size for
            the next step that will be taken.
            </summary>
            <remarks>
            This function is given a dWorldID because, in the future, the force computation may depend on integrator
            parameters that are set as properties of the world.
            </remarks>
            <param name="world">A  dWorldID</param>
            <param name="stepsize">A  dReal</param>
            <param name="ix">A  dReal</param>
            <param name="iy">A  dReal</param>
            <param name="iz">A  dReal</param>
            <param name="force">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldStep(System.IntPtr,System.Single)">
            <summary>
            Step the world.
            This uses a "big matrix" method that takes time on the order of m3 and memory on the order of m2,
            where m is the total number of constraint rows.
                        For large systems this will use a lot of memory and can be very slow, but this is currently the
            most accurate method.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="stepsize">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldQuickStep(System.IntPtr,System.Single)">
            <summary>
            Step the world.
            This uses an iterative method that takes time on the order of m*N and memory on the order of m, where
            m is the total number of constraint rows and N is the number of iterations.
                        For large systems this is a lot faster than dWorldStep, but it is less accurate.
            </summary>
            <remarks>
            QuickStep is great for stacks of objects especially when the auto-disable feature is used as well.
            However, it has poor accuracy for near-singular systems. Near-singular systems can occur when using
            high-friction contacts, motors, or certain articulated structures.
            For example, a robot with multiple legs sitting on the ground may be near-singular.
                        There are ways to help overcome QuickStep's inaccuracy problems:
            	- 	Increase CFM.
            	-	Reduce the number of contacts in your system (e.g. use the minimum number of contacts for
                	the feet of a robot or creature).
            	-	Don't use excessive friction in the contacts.
            	-	Use contact slip if appropriate
            	-	Avoid kinematic loops (however, kinematic loops are inevitable in legged creatures).
            	-	Don't use excessive motor strength.
            	-	Use force-based motors instead of velocity-based motors.
                        Increasing the number of QuickStep iterations may help a little bit, but it is not going to help much
            if your system is really near singular.
            </remarks>
            <param name="world">A  dWorldID</param>
            <param name="stepsize">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetQuickStepNumIterations(System.IntPtr,System.Int32)">
            <summary>
            Set the number of iterations that the QuickStep method performs per step.
                        More iterations will give a more accurate solution, but will take longer to compute.
                        The default is 20 iterations.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="num">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetQuickStepNumIterations(System.IntPtr)">
            <summary>
            Get the number of iterations that the QuickStep method performs per step.
                        The default is 20 iterations.
            </summary>
            <returns>An int</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetQuickStepW(System.IntPtr,System.Single)">
            <summary>
            Set the QuickStep SOR over-relaxation parameter
            </summary>
            <remarks>
            Summary obtained from code - otherwise undocumented
            </remarks>
            <param name="world">A  dWorldID</param>
            <param name="param">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetQuickStepW(System.IntPtr)">
            <summary>
            Get the QuickStep SOR over-relaxation parameter
            </summary>
            <remarks>
            Summary obtained from code - otherwise undocumented
            </remarks>
            <returns>A dReal</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetContactMaxCorrectingVel(System.IntPtr,System.Single)">
            <summary>
            Set maximum correcting velocity that contacts are allowed to generate.
                        The default value is infinity (i.e. no limit).
                        Reducing this value can help prevent "popping" of deeply embedded objects.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="vel">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetContactMaxCorrectingVel(System.IntPtr)">
            <summary>
            Get the maximum correcting velocity that contacts are allowed to generate.
                        The default value is infinity (i.e. no limit).
            </summary>
            <returns>A dReal</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetContactSurfaceLayer(System.IntPtr,System.Single)">
            <summary>
            Set the depth of the surface layer around all geometry objects.
                        Contacts are allowed to sink into the surface layer up to the given depth before coming to rest.
                        The default value is zero.
                        Increasing this to some small value (e.g. 0.001) can help prevent jittering problems due to contacts
            being repeatedly made and broken.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="depth">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetContactSurfaceLayer(System.IntPtr)">
            <summary>
            Get the depth of the surface layer around all geometry objects.
                        The default value is zero.
            </summary>
            <returns>A dReal</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldStepFast1(System.IntPtr,System.Single,System.Int32)">
            <summary>
            Step the world by stepsize seconds using the StepFast1 algorithm.
            The number of iterations to perform is given by maxiterations.
                        NOTE: The StepFast algorithm has been superseded by the QuickStep algorithm: see the dWorldQuickStep function.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="stepsize">A  dReal</param>
            <param name="maxiterations">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetAutoEnableDepthSF1(System.IntPtr,System.Int32)">
            <summary>
            Set the AutoEnableDepth parameter used by the StepFast1 algorithm.
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="autoEnableDepth">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetAutoEnableDepthSF1(System.IntPtr)">
            <summary>
            Get the AutoEnableDepth parameter used by the StepFast1 algorithm.
            </summary>
            <returns>An int</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetAutoDisableFlag(System.IntPtr,System.Int32)">
            <summary>
            Set the default auto-disable flag for newly created bodies.
                        The default parameter is:  AutoDisableFlag = disabled
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="do_auto_disable">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetAutoDisableFlag(System.IntPtr)">
            <summary>
            Get the current auto-disable flag for newly created bodies.
            </summary>
            <returns>An int</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetAutoDisableLinearThreshold(System.IntPtr,System.Single)">
            <summary>
            Set the default auto-disable linear threshold for newly created bodies.
                        The default parameter is:  AutoDisableLinearThreshold = 0.01
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="linear_threshold">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetAutoDisableLinearThreshold(System.IntPtr)">
            <summary>
            Get the current auto-disable linear threshold for newly created bodies.
            </summary>
            <returns>A dReal</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetAutoDisableAngularThreshold(System.IntPtr,System.Single)">
            <summary>
            Set the default auto-disable angular threshold for newly created bodies.
                        The default parameter is:  AutoDisableAngularThreshold = 0.01
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="angular_threshold">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetAutoDisableAngularThreshold(System.IntPtr)">
            <summary>
            Get the current auto-disable angular threshold for newly created objects
            </summary>
            <returns>A dReal</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetAutoDisableSteps(System.IntPtr,System.Int32)">
            <summary>
            Set the default auto-disable steps for newly created bodies.
                        The default parameter is:  AutoDisableSteps = 10
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="steps">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetAutoDisableSteps(System.IntPtr)">
            <summary>
            Get the current auto-disable steps for newly created bodies
            </summary>
            <returns>An int</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldSetAutoDisableTime(System.IntPtr,System.Single)">
            <summary>
            Set the default auto-disable time for newly created bodies.
                        The default parameter is:  AutoDisableTime = 0
            </summary>
            <param name="world">A  dWorldID</param>
            <param name="time">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dWorldGetAutoDisableTime(System.IntPtr)">
            <summary>
            Get the current auto-disable time for newly created bodies.
            </summary>
            <returns>A dReal</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyCreate(System.IntPtr)">
            <summary>
            Create a body in the given world with default mass parameters at position (0,0,0).
            Return its ID (really a handle to the body).
            </summary>
            <returns>A dBodyID</returns>
            <param name="world">A  dWorldID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyDestroy(System.IntPtr)">
            <summary>
            Destroy a body.
                        All joints that are attached to this body will be put into limbo (i.e. unattached and
            not affecting the simulation, but they will NOT be deleted)
            </summary>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetPosition(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the position of the body.
                        After setting a group of bodies, the outcome of the simulation is undefined if the new configuration
            is inconsistent with the joints/constraints that are present.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetRotation(System.IntPtr,Tao.Ode.Ode.dMatrix3@)">
            <summary>
            Set the rotation of the body.
                        After setting a group of bodies, the outcome of the simulation is undefined if the new configuration
            is inconsistent with the joints/constraints that are present.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="R">A  dMatrix3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetQuaternion(System.IntPtr,Tao.Ode.Ode.dQuaternion@)">
            <summary>
            Set the orientation on of the body.
                        Orientation is represented by a quaternion (qs,qx,qy,qz)
                        After setting a group of bodies, the outcome of the simulation is undefined if the new configuration
            is inconsistent with the joints/constraints that are present.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="q">A  dQuaternion</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetLinearVel(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the linear velocity of the body.
                        After setting a group of bodies, the outcome of the simulation is undefined if the new configuration
            is inconsistent with the joints/constraints that are present.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetAngularVel(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the angular velocity of the body.
                        After setting a group of bodies, the outcome of the simulation is undefined if the new configuration
            is inconsistent with the joints/constraints that are present.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetPosition(System.IntPtr)">
            <summary>
            Get the position of the body
                        The vector is valid until any changes are made to the rigid body system structure.
            </summary>
            <returns>A dVector3</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetRotation(System.IntPtr)">
            <summary>
            Get the rotation of the body.
                        The returned value is a 4x3 rotation matrix.
            The matrix is valid until any changes are made to the rigid body system structure.
            </summary>
            <returns>A dMatrix3</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetQuaternion(System.IntPtr)">
            <summary>
            Get the orientation of a body.
                        Orientation is represented by a quaternion (qs,qx,qy,qz)
            </summary>
            <returns>A dQuaternion</returns>
            <param name="body">A  dBodyID</param>
            TODO: This seems to be unfinished.  Need completion and testing.
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetLinearVel(System.IntPtr)">
            <summary>
            Get the linear velocity of a body
                        The vector is valid until any changes are made to the rigid body system structure.
            </summary>
            <returns>A dVector3</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetAngularVel(System.IntPtr)">
            <summary>
            Get the angular velocity of a body
                        The vector is valid until any changes are made to the rigid body system structure.
            </summary>
            <returns>A dVector3</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetMass(System.IntPtr,Tao.Ode.Ode.dMass@)">
            <summary>
            Set the mass of the body (see the mass functions)
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="mass">A  dMass</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetMass(System.IntPtr,Tao.Ode.Ode.dMass@)">
            <summary>
            Get the mass of the body (see the mass functions)
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="mass">A  dMass</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyAddForce(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Add force to a body using absolute coordinates.
            </summary>
            <remarks>
            Forces are accumulated on to each body, and the accumulators are zeroed after each time step.
                        Force is applied at body's center of mass
            </remarks>
            <param name="body">A  dBodyID</param>
            <param name="fx">A  dReal</param>
            <param name="fy">A  dReal</param>
            <param name="fz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyAddTorque(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Add torque to a body using absolute coordinates.
            </summary>
            <remarks>
            Forces are accumulated on to each body, and the accumulators are zeroed after each time step.
                        Force is applied at body's center of mass
            </remarks>
            <param name="body">A  dBodyID</param>
            <param name="fx">A  dReal</param>
            <param name="fy">A  dReal</param>
            <param name="fz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyAddRelForce(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Add force to a body using relative coordinates.
                        This function takes a force vector that is relative to the body's own frame of reference.
            </summary>
            <remarks>
            Forces are accumulated on to each body, and the accumulators are zeroed after each time step.
                        Force is applied at body's center of mass
            </remarks>
            <param name="body">A  dBodyID</param>
            <param name="fx">A  dReal</param>
            <param name="fy">A  dReal</param>
            <param name="fz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyAddRelTorque(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Add torque to a body using relative coordinates.
                        This function takes a force vector that is relative to the body's own frame of reference.
            </summary>
            <remarks>
            Forces are accumulated on to each body, and the accumulators are zeroed after each time step.
                        Force is applied at body's center of mass
            </remarks>
            <param name="body">A  dBodyID</param>
            <param name="fx">A  dReal</param>
            <param name="fy">A  dReal</param>
            <param name="fz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyAddForceAtPos(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Add force to a body using absolute coordinates at specified absolute position.
                        The supplied position vector specifies the point at which the force is supplied in global coordinates.
            </summary>
            <remarks>
            Forces are accumulated on to each body, and the accumulators are zeroed after each time step.
                        Force is applied at specified point.
            </remarks>
            <param name="body">A  dBodyID</param>
            <param name="fx">A  dReal</param>
            <param name="fy">A  dReal</param>
            <param name="fz">A  dReal</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyAddForceAtRelPos(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Add force to a body using absolute coordinates at specified relative position.
                        The supplied position vector specifies the point at which the force is supplied in body-relative coordinates.
            </summary>
            <remarks>
            Forces are accumulated on to each body, and the accumulators are zeroed after each time step.
                        Force is applied at specified point.
            </remarks>
            <param name="body">A  dBodyID</param>
            <param name="fx">A  dReal</param>
            <param name="fy">A  dReal</param>
            <param name="fz">A  dReal</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyAddRelForceAtPos(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Add force to a body using body-relative coordinates at specified absolute position.
                        The supplied position vector specifies the point at which the force is supplied in global coordinates.
            </summary>
            <remarks>
            Forces are accumulated on to each body, and the accumulators are zeroed after each time step.
                        Force is applied at specified point.
            </remarks>
            <param name="body">A  dBodyID</param>
            <param name="fx">A  dReal</param>
            <param name="fy">A  dReal</param>
            <param name="fz">A  dReal</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyAddRelForceAtRelPos(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Add force to a body using body-relative coordinates at specified relative position.
                        The supplied position vector specifies the point at which the force is supplied in body-relative coordinates.
            </summary>
            <remarks>
            Forces are accumulated on to each body, and the accumulators are zeroed after each time step.
                        Force is applied at specified point.
            </remarks>
            <param name="body">A  dBodyID</param>
            <param name="fx">A  dReal</param>
            <param name="fy">A  dReal</param>
            <param name="fz">A  dReal</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetForce(System.IntPtr)">
            <summary>
            Return the current accumulated force on the body.
            </summary>
            <remarks>
            In ODE, the returned values are pointers to internal data structures, so the vectors are only valid until any
            changes are made to the rigid body system.
            </remarks>
            <returns>A dVector3</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetTorque(System.IntPtr)">
            <summary>
            Return the current accumulated torque on the body.
            </summary>
            <remarks>
            In ODE, the returned values are pointers to internal data structures, so the vectors are only valid until any
            changes are made to the rigid body system.
            </remarks>
            <returns>A dVector3</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetForce(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the body force accumulation vector.
            This is mostly useful to zero the force and torque for deactivated bodies before they are reactivated,
            in the case where the force-adding functions were called on them while they were deactivated.
            </summary>
            <param name="b">A  dBodyID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetTorque(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the body torque accumulation vector.
            This is mostly useful to zero the force and torque for deactivated bodies before they are reactivated,
            in the case where the force-adding functions were called on them while they were deactivated.
            </summary>
            <param name="b">A  dBodyID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetRelPointPos(System.IntPtr,System.Single,System.Single,System.Single,Tao.Ode.Ode.dVector3@)">
            <summary>
            Take a point on a body (px,py,pz) and return that point's position in body-relative coordinates (in result).
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetRelPointVel(System.IntPtr,System.Single,System.Single,System.Single,Tao.Ode.Ode.dVector3@)">
            <summary>
            Take a point on a body (px,py,pz) and return that point's velocity in body-relative coordinates (in result).
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetPointVel(System.IntPtr,System.Single,System.Single,System.Single,Tao.Ode.Ode.dVector3@)">
            <summary>
            Take a point on a body (px,py,pz) and return that point's position in absolute coordinates (in result).
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetPosRelPoint(System.IntPtr,System.Single,System.Single,System.Single,Tao.Ode.Ode.dVector3@)">
            <summary>
            This is the inverse of dBodyGetRelPointPos.
            It takes a point in global coordinates (x,y,z) and returns the point's position in body-relative
            coordinates (result).
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyVectorToWorld(System.IntPtr,System.Single,System.Single,System.Single,Tao.Ode.Ode.dVector3@)">
            <summary>
            Given a vector expressed in the body coordinate system (x,y,z), rotate it to the world coordinate system (result).
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyVectorFromWorld(System.IntPtr,System.Single,System.Single,System.Single,Tao.Ode.Ode.dVector3@)">
            <summary>
            Given a vector expressed in the world coordinate system (x,y,z), rotate it to the body coordinate system (result).
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetData(System.IntPtr,System.IntPtr)">
            <summary>
            Set the body's user-data pointer.
                        WARNING: It is unclear from the ODE source and the documentation what the nature of
            user-data is.
            This function is here for the sake of completeness because it is part of ODE's public API, but
            has NOT been tested in any way.
                        Use at own risk.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="data">An IntPtr</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetData(System.IntPtr)">
            <summary>
            Get the body's user-data pointer.
                        WARNING: It is unclear from the ODE source and the documentation what the nature of
            user-data is.
            This function is here for the sake of completeness because it is part of ODE's public API, but
            has NOT been tested in any way.
                        Use at own risk.
            </summary>
            <returns>An IntPtr</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetFiniteRotationMode(System.IntPtr,System.Int32)">
            <summary>
            This function controls the way a body's orientation is updated at each time step. The mode argument can be:
                        	-	0: An ``infinitesimal'' orientation update is used. This is fast to compute, but it can occasionally
            		cause inaccuracies for bodies that are rotating at high speed, especially when those bodies are
            		joined to other bodies.
            		This is the default for every new body that is created.
                        	-	1: A ``finite'' orientation update is used. This is more costly to compute, but will be more
            		accurate for high speed rotations. Note however that high speed rotations can result in many
            		types of error in a simulation, and this mode will only fix one of those sources of error.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="mode">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetFiniteRotationMode(System.IntPtr)">
            <summary>
            Return the current finite rotation mode of a body (0 or 1).
            </summary>
            <returns>An int</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetFiniteRotationAxis(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            This sets the finite rotation axis for a body.
            This axis only has meaning when the finite rotation mode is set (see dBodySetFiniteRotationMode).
                        If this axis is zero (0,0,0), full finite rotations are performed on the body.
                        If this axis is nonzero, the body is rotated by performing a partial finite rotation along the axis direction
            followed by an infinitesimal rotation along an orthogonal direction.
                        This can be useful to alleviate certain sources of error caused by quickly spinning bodies. For example, if a
            car wheel is rotating at high speed you can call this function with the wheel's hinge axis as the argument to
            try and improve its behavior.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetFiniteRotationAxis(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Return the current finite rotation axis of a body.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetNumJoints(System.IntPtr)">
            <summary>
            Return the number of joints that are attached to this body.
            </summary>
            <returns>An int</returns>
            <param name="b">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetJoint(System.IntPtr,System.Int32)">
            <summary>
            Return a joint attached to this body, given by index.
                        Valid indexes are 0 to n-1 where n is the value returned by dBodyGetNumJoints.
            </summary>
            <returns>A dJointID</returns>
            <param name="body">A  dBodyID</param>
            <param name="index">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetGravityMode(System.IntPtr,System.Int32)">
            <summary>
            Set whether the body is influenced by the world's gravity or not.
                        If mode is nonzero it is, if mode is zero, it isn't.
                        Newly created bodies are always influenced by the world's gravity.
            </summary>
            <param name="b">A  dBodyID</param>
            <param name="mode">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetGravityMode(System.IntPtr)">
            <summary>
            Get whether the body is influenced by the world's gravity or not.
                        If mode is nonzero it is, if mode is zero, it isn't.
            </summary>
            <returns>An int</returns>
            <param name="b">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyEnable(System.IntPtr)">
            <summary>
            Manually enable a body.
            Note that a disabled body that is connected through a joint to an enabled body
            will be automatically re-enabled at the next simulation step.
            </summary>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyDisable(System.IntPtr)">
            <summary>
            Manually disable a body.
            Note that a disabled body that is connected through a joint to an enabled body
            will be automatically re-enabled at the next simulation step.
            </summary>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyIsEnabled(System.IntPtr)">
            <summary>
            Method dBodyIsEnabled
            Return 1 if a body is currently enabled or 0 if it is disabled.
            </summary>
            <returns>An int</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetAutoDisableFlag(System.IntPtr,System.Int32)">
            <summary>
            Method dBodySetAutoDisableFlag
            Set the auto-disable flag of a body.
                        If the do_auto_disable is nonzero the body will be automatically disabled when it has been idle for long enough.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="do_auto_disable">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetAutoDisableFlag(System.IntPtr)">
            <summary>
            Method dBodyGetAutoDisableFlag
            Get the auto-disable flag of a body.
                        If the do_auto_disable is nonzero the body will be automatically disabled when it has been idle for long enough.
            </summary>
            <returns>An int</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetAutoDisableLinearThreshold(System.IntPtr,System.Single)">
            <summary>
            Method dBodySetAutoDisableLinearThreshold
            Set a body's linear velocity threshold for automatic disabling.
                        The body's linear velocity magnitude must be less than this threshold for
            it to be considered idle.
                        Set the threshold to dInfinity to prevent the linear velocity from being considered.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="linear_threshold">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetAutoDisableLinearThreshold(System.IntPtr)">
            <summary>
            Method dBodyGetAutoDisableLinearThreshold
            Get a body's linear velocity threshold for automatic disabling.
                        The body's linear velocity magnitude must be less than this threshold for
            it to be considered idle.
                        Set the threshold to dInfinity to prevent the linear velocity from being considered.
            </summary>
            <returns>A dReal</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetAutoDisableAngularThreshold(System.IntPtr,System.Single)">
            <summary>
            Method dBodySetAutoDisableAngularThreshold
            Set a body's angular velocity threshold for automatic disabling.
                        The body's linear angular magnitude must be less than this threshold for
            it to be considered idle.
                        Set the threshold to dInfinity to prevent the angular velocity from being considered.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="angular_threshold">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetAutoDisableAngularThreshold(System.IntPtr)">
            <summary>
            Method dBodyGetAutoDisableAngularThreshold
            Get a body's angular velocity threshold for automatic disabling.
                        The body's linear angular magnitude must be less than this threshold for
            it to be considered idle.
                        Set the threshold to dInfinity to prevent the angular velocity from being considered.
            </summary>
            <returns>A dReal</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetAutoDisableSteps(System.IntPtr,System.Int32)">
            <summary>
            Method dBodySetAutoDisableSteps
            Set the number of simulation steps that a body must be idle before
            it is automatically disabled.
                        Set this to zero to disable consideration of the number of steps.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="steps">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetAutoDisableSteps(System.IntPtr)">
            <summary>
            Method dBodyGetAutoDisableSteps
            Get the number of simulation steps that a body must be idle before
            it is automatically disabled.
                         If zero, consideration of the number of steps is disabled.
            </summary>
            <returns>An int</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetAutoDisableTime(System.IntPtr,System.Single)">
            <summary>
            Method dBodySetAutoDisableTime
            Set the amount of simulation time that a body must be idle before
            it is automatically disabled.
                        Set this to zero to disable consideration of the amount of simulation time.
            </summary>
            <param name="body">A  dBodyID</param>
            <param name="time">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodyGetAutoDisableTime(System.IntPtr)">
            <summary>
            Method dBodyGetAutoDisableTime
            Get the amount of simulation time that a body must be idle before
            it is automatically disabled.
                        If zero, consideration of the amount of simulation time is disabled.
            </summary>
            <returns>A dReal</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBodySetAutoDisableDefaults(System.IntPtr)">
            <summary>
            Method dBodySetAutoDisableDefaults
            Set the auto-disable parameters of the body to the default parameters
            that have been set on the world.
            </summary>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateBall(System.IntPtr,System.IntPtr)">
            <summary>
            Create a new ball joint.
                        The joint is initially in "limbo" (i.e. it has no effect on the simulation)
            because it does not connect to any bodies.
                        The joint group ID is 0 to allocate the joint normally.
            If it is nonzero the joint is allocated in the given joint group.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateHinge(System.IntPtr,System.IntPtr)">
            <summary>
            Create a new hinge joint.
                        The joint is initially in "limbo" (i.e. it has no effect on the simulation)
            because it does not connect to any bodies.
                        The joint group ID is 0 to allocate the joint normally.
            If it is nonzero the joint is allocated in the given joint group.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateSlider(System.IntPtr,System.IntPtr)">
            <summary>
            Create a new slider joint.
                        The joint is initially in "limbo" (i.e. it has no effect on the simulation)
            because it does not connect to any bodies.
                        The joint group ID is 0 to allocate the joint normally.
            If it is nonzero the joint is allocated in the given joint group.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateContact(System.IntPtr,System.IntPtr,Tao.Ode.Ode.dContact@)">
            <summary>
            Create a new contact joint.
                        The joint is initially in "limbo" (i.e. it has no effect on the simulation)
            because it does not connect to any bodies.
                        The joint group ID is 0 to allocate the joint normally.
            If it is nonzero the joint is allocated in the given joint group.
                        The contact joint will be initialized with the given dContact structure.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateHinge2(System.IntPtr,System.IntPtr)">
            <summary>
            Create a new hinge-2 joint.
                        The joint is initially in "limbo" (i.e. it has no effect on the simulation)
            because it does not connect to any bodies.
                        The joint group ID is 0 to allocate the joint normally.
            If it is nonzero the joint is allocated in the given joint group.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateUniversal(System.IntPtr,System.IntPtr)">
            <summary>
            Create a new universal joint.
                        The joint is initially in "limbo" (i.e. it has no effect on the simulation)
            because it does not connect to any bodies.
                        The joint group ID is 0 to allocate the joint normally.
            If it is nonzero the joint is allocated in the given joint group.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateFixed(System.IntPtr,System.IntPtr)">
            <summary>
            Create a new fixed joint.
                        The joint is initially in "limbo" (i.e. it has no effect on the simulation)
            because it does not connect to any bodies.
                        The joint group ID is 0 to allocate the joint normally.
            If it is nonzero the joint is allocated in the given joint group.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateAMotor(System.IntPtr,System.IntPtr)">
            <summary>
            Create a new angular motor joint.
                        The joint is initially in "limbo" (i.e. it has no effect on the simulation)
            because it does not connect to any bodies.
                        The joint group ID is 0 to allocate the joint normally.
            If it is nonzero the joint is allocated in the given joint group.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointCreateNull(System.IntPtr,System.IntPtr)">
            <summary>
            Create a new "null" joint.
                        There's no discussion of this in the docs or sourcecode.
            The only mention is the following entry in the ODE Changelog:
                        	10/11/01 russ
                        	* joints can now return m=0 to be "inactive". added a "null" joint
            	to test this.
                        This suggests a null joint is mainly useful for testing and should probably
            be ignored by users of the bindings.
            </summary>
            <returns>A dJointID</returns>
            <param name="world">A  dWorldID</param>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointDestroy(System.IntPtr)">
            <summary>
            Destroy a joint, disconnecting it from its attached bodies and removing it from the world.
            However, if the joint is a member of a group then this function has no effect - to destroy
            that joint the group must be emptied or destroyed.
            </summary>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGroupCreate(System.Int32)">
            <summary>
            Create a joint group.
                        NOTE: 	The max_size argument is no longer used and should be set to 0.
            		It is kept for backwards compatibility.
            </summary>
            <returns>A dJointGroupID</returns>
            <param name="max_size">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGroupDestroy(System.IntPtr)">
            <summary>
            Destroy a joint group. All joints in the joint group will be destroyed.
            </summary>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGroupEmpty(System.IntPtr)">
            <summary>
            Empty a joint group.
            All joints in the joint group will be destroyed, but the joint group itself will not be destroyed.
            </summary>
            <param name="group">A  dJointGroupID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointAttach(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Attach the joint to some new bodies.
                        If the joint is already attached, it will be detached from the old bodies first.
            To attach this joint to only one body, set body1 or body2 to zero - a zero body
            refers to the static environment.
            Setting both bodies to zero puts the joint into "limbo", i.e. it will have no
            effect on the simulation.
            Some joints, like hinge-2 need to be attached to two bodies to work.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="body1">A  dBodyID</param>
            <param name="body2">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetData(System.IntPtr,System.IntPtr)">
            <summary>
            Set the joint's user-data pointer.
                        WARNING: It is unclear from the ODE source and the documentation what the nature of
            user-data is.
            This function is here for the sake of completeness because it is part of ODE's public API, but
            has NOT been tested in any way.
                        Use at own risk.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="data">An IntPtr</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetData(System.IntPtr)">
            <summary>
            Get the joint's user-data pointer.
                        WARNING: It is unclear from the ODE source and the documentation what the nature of
            user-data is.
            This function is here for the sake of completeness because it is part of ODE's public API, but
            has NOT been tested in any way.
                        Use at own risk.
            </summary>
            <returns>An IntPtr</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetType(System.IntPtr)">
            <summary>
            Get the joint's type.
                        The available joint types are:
            	dJointTypeBall:  		A ball-and-socket joint.
            	dJointTypeHinge:  		A hinge joint.
            	dJointTypeSlider:  		A slider joint.
            	dJointTypeContact:		A contact joint.
            	dJointTypeUniversal:	A universal joint.
            	dJointTypeHinge2:		A hinge-2 joint.
            	dJointTypeFixed:		A fixed joint.
            	dJointTypeAMotor:		An angular motor joint.
            </summary>
            <returns>An int</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetBody(System.IntPtr,System.Int32)">
            <summary>
            Return the bodies that this joint connects.
                        If index is 0 the ``first'' body will be returned,
            corresponding to the body1 argument of dJointAttach.
            If index is 1 the ``second'' body will be returned,
            corresponding to the body2 argument of dJointAttach.
                        If one of these returned body IDs is zero, the joint
            connects the other body to the static environment.
                        If both body IDs are zero, the joint is in ``limbo'' and has no effect on the simulation.
            </summary>
            <returns>A dBodyID</returns>
            <param name="joint">A  dJointID</param>
            <param name="index">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetFeedback(System.IntPtr,Tao.Ode.Ode.dJointFeedback@)">
            <summary>
            Pass a dJointFeedback structure to the joint to collect information about
            the forces applied by each joint.
                        Notes from the ODE docs:
            	During the world time step, the forces that are applied by each joint are computed.
            	These forces are added directly to the joined bodies, and the user normally has no
            	way of telling which joint contributed how much force.
            	If this information is desired then the user can allocate a dJointFeedback structure
            	and pass its pointer to the dJointSetFeedback() function.
                        	The feedback information structure is defined as follows (NOTE: C# version listed here):
            			public struct dJointFeedback {
            				public dVector3 f1;		/* force that joint applies to body 1  */
            				public dVector3 t1;		/* torque that joint applies to body 1 */
            				public dVector3 f2;		/* force that joint applies to body 2  */
            				public dVector3 t2;		/* torque that joint applies to body 2 */
            			};
            	During the time step any feedback structures that are attached to joints will be
            	filled in with the joint's force and torque information.
                        	The dJointGetFeedback() function returns the current feedback structure pointer,
            	or 0 if none is used (this is the default).
                        	dJointSetFeedback() can be passed 0 to disable feedback for that joint.
                        	TODO: Will passing 0 work?  Seems as if something else needs to be passed here
                        	Now for some API design notes. It might seem strange to require that users perform the
            	allocation of these structures. Why not just store the data statically in each joint?
            	The reason is that not all users will use the feedback information, and even when it
            	is used not all joints will need it. It will waste memory to store it statically,
            	especially as this structure could grow to store a lot of extra information in the future.
            	Why not have ODE allocate the structure itself, at the user's request? The reason is
            	that contact joints (which are created and destroyed every time step) would require a
            	lot of time to be spent in memory allocation if feedback is required. Letting the user
            	do the allocation means that a better allocation strategy can be provided, e.g simply
            	allocating them out of a fixed array.
                        	The alternative to this API is to have a joint-force callback. This would work of course,
            	but it has a few problems. First, callbacks tend to pollute APIs and sometimes require
            	the user to go through unnatural contortions to get the data to the right place.
            	Second, this would expose ODE to being changed in the middle of a step (which would have
            	bad consequences), and there would have to be some kind of guard against this or a debugging
            	check for it - which would complicate things.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="feedback">A  dJointFeedback</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetFeedback(System.IntPtr)">
            <summary>
            Get the jointfeedback structure from the joint to get information about
            the forces applied by each joint.
                        	The feedback information structure is defined as follows (NOTE: C# version listed here):
            			public struct dJointFeedback {
            				public dVector3 f1;		/* force that joint applies to body 1  */
            				public dVector3 t1;		/* torque that joint applies to body 1 */
            				public dVector3 f2;		/* force that joint applies to body 2  */
            				public dVector3 t2;		/* torque that joint applies to body 2 */
            			};
                        	The dJointGetFeedback() function returns the current feedback structure pointer,
            	or 0 if none is used (this is the default).
            	TODO: Will passing 0 work or does something special have to be done?
            </summary>
            <returns>A dJointFeedback</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dAreConnected(System.IntPtr,System.IntPtr)">
            <summary>
            Test if the two specified bodies are connected by a joint.
                        Return 1 if yes, otherwise return 0
            </summary>
            <returns>An int</returns>
            <param name="body1">A  dBodyID</param>
            <param name="body2">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dAreConnectedExcluding(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return 1 if the two bodies are connected together by a joint that does not
            have type joint_type, otherwise return 0.
            joint_type is a dJointTypeXXX constant.
            This is useful for deciding whether to add contact joints between two bodies:
            if they are already connected by non-contact joints then it may not be
            appropriate to add contacts, however it is okay to add more contact between
            bodies that already have contacts.
            </summary>
            <returns>An int</returns>
            <param name="body1">A  dBodyID</param>
            <param name="body2">A  dBodyID</param>
            <param name="joint_type">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetBallAnchor(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Method dJointSetBallAnchor
            Set the joint anchor point.
            The joint will try to keep this point on each body together.
            The input is specified in world coordinates.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetBallAnchor(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Method dJointGetBallAnchor
            Get the joint anchor point on body 1, in world coordinates.
            If the joint is perfectly satisfied, this will be the same as the point on body 2.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetBallAnchor2(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Method dJointGetBallAnchor2
            Get the joint anchor point on body 2, in world coordinates.
            You can think of a ball and socket joint as trying to keep the
            result of dJointGetBallAnchor() and dJointGetBallAnchor2() the same.
            If the joint is perfectly satisfied, this function will return the
            same value as dJointGetBallAnchor to within roundoff errors.
            dJointGetBallAnchor2 can be used, along with dJointGetBallAnchor,
            to see how far the joint has come apart.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetHingeAnchor(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set hinge anchor parameters
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetHingeAxis(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set hinge axis parameters
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHingeAnchor(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the joint anchor point, in world coordinates.
            This returns the point on body 1.
            If the joint is perfectly satisfied, this will be the same as the point on body 2.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHingeAnchor2(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the joint anchor point, in world coordinates.
            This returns the point on body 2.
            If the joint is perfectly satisfied, this will return the same value as dJointGetHingeAnchor.
            If not, this value will be slightly different.
            This can be used, for example, to see how far the joint has come apart.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHingeAxis(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the hinge axis parameter for the joint.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHingeAngle(System.IntPtr)">
            <summary>
            Get the hinge angle of the joint.
            The angle is measured between the two bodies, or between the body
            and the static environment.
            The angle will be between -pi..pi.
            When the hinge anchor or axis is set, the current position of the
            attached bodies is examined and that position will be the zero angle.
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHingeAngleRate(System.IntPtr)">
            <summary>
            Get the time derivative of the hinge angle of the joint
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetHingeParam(System.IntPtr,System.Int32,System.Single)">
            <summary>
            Set limit/motor parameters for a hinge joint
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
            <param name="value">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHingeParam(System.IntPtr,System.Int32)">
            <summary>
            Get limit/motor parameters for a hinge joint
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointAddHingeTorque(System.IntPtr,System.Single)">
            <summary>
            Applies the torque about the hinge axis.
                        That is, it applies a torque with magnitude torque, in the direction of
            the hinge axis, to body 1, and with the same magnitude but in opposite
            direction to body 2.
            </summary>
            <remarks>
            This function is just a wrapper for dBodyAddTorque
            </remarks>
            <param name="joint">A  dJointID</param>
            <param name="torque">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetSliderAxis(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the slider axis parameter.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetSliderAxis(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the slider axis parameter
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetSliderPosition(System.IntPtr)">
            <summary>
            Get the slider linear position (i.e. the slider's ``extension'')
                        When the axis is set, the current position of the attached bodies
            is examined and that position will be the zero position.
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetSliderPositionRate(System.IntPtr)">
            <summary>
            Get the time derivative of the slider linear position.
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetSliderParam(System.IntPtr,System.Int32,System.Single)">
            <summary>
            Set limit/motor parameters for a slider joint
                        See http://ode.org/ode-latest-userguide.html#sec_7_5_1 for details
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
            <param name="value">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetSliderParam(System.IntPtr,System.Int32)">
            <summary>
            Get limit/motor parameters for a slider joint
                        See http://ode.org/ode-latest-userguide.html#sec_7_5_1 for details
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointAddSliderForce(System.IntPtr,System.Single)">
            <summary>
            Applies the given force in the slider's direction.
            That is, it applies a force with magnitude force, in the direction
            slider's axis, to body1, and with the same magnitude but opposite
            direction to body2.
            </summary>
            <remarks>
            This function is just a wrapper for dBodyAddForce.
            </remarks>
            <param name="joint">A  dJointID</param>
            <param name="force">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetHinge2Anchor(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set hinge-2 anchor parameters
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetHinge2Axis1(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set hinge-2 axis 1 parameters
                        Axis 1 and axis 2 must not lie on the same line
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetHinge2Axis2(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set hinge-2 axis 2 parameters
                        Axis 1 and axis 2 must not lie on the same line
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHinge2Anchor(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the joint anchor point, in world coordinates.
            This returns the point on body 1.
            If the joint is perfectly satisfied, this will be the same as the point on body 2.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHinge2Anchor2(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the joint anchor point, in world coordinates.
            This returns the point on body 2.
            If the joint is perfectly satisfied, this will return the same value as dJointGetHinge2Anchor.
            If not, this value will be slightly different.
            This can be used, for example, to see how far the joint has come apart.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHinge2Axis1(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get hinge-2 axis 1 parameters.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHinge2Axis2(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get hinge-2 axis 2 parameters.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHinge2Angle1(System.IntPtr)">
            <summary>
            Get the hinge-2 angles (around axis 1 and axis 2)
                        When the anchor or axis is set, the current position of the attached bodies
            is examined and that position will be the zero angle.
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHinge2Angle1Rate(System.IntPtr)">
            <summary>
            Get the time derivative of hinge-2 angle 1
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHinge2Angle2Rate(System.IntPtr)">
            <summary>
            Get the time derivative of hinge-2 angle 2
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetHinge2Param(System.IntPtr,System.Int32,System.Single)">
            <summary>
            Set limit/motor parameters for a hinge-2 joint
                        See http://ode.org/ode-latest-userguide.html#sec_7_5_1 for details
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
            <param name="value">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetHinge2Param(System.IntPtr,System.Int32)">
            <summary>
            Get limit/motor parameters for a hinge-2 joint
                        See http://ode.org/ode-latest-userguide.html#sec_7_5_1 for details
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointAddHinge2Torques(System.IntPtr,System.Single,System.Single)">
            <summary>
            Applies torque1 about the hinge2's axis 1, and torque2 about the hinge2's axis 2.
            This function is just a wrapper for dBodyAddTorque.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="torque1">A  dReal</param>
            <param name="torque2">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetUniversalAnchor(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set universal joint anchor parameters.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetUniversalAxis1(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set universal joint axis 1 parameters
                        Axis 1 and axis 2 should be perpendicular to each other.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetUniversalAxis2(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set universal joint axis 2 parameters
                        Axis 1 and axis 2 should be perpendicular to each other.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetUniversalAnchor(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the joint anchor point, in world coordinates.
            This returns the point on body 1.
            If the joint is perfectly satisfied, this will be the same as the point on body 2.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetUniversalAnchor2(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the joint anchor point, in world coordinates.
            This returns the point on body 2.
            You can think of the ball and socket part of a universal joint as trying
            to keep the result of dJointGetBallAnchor() and dJointGetBallAnchor2() the same.
            If the joint is perfectly satisfied, this function will return the same value as
            dJointGetUniversalAnchor to within roundoff errors.
            dJointGetUniversalAnchor2 can be used, along with dJointGetUniversalAnchor, to
            see how far the joint has come apart.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetUniversalAxis1(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get parameters for universal joint axis 1
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetUniversalAxis2(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get parameters for universal joint axis 2
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetUniversalParam(System.IntPtr,System.Int32,System.Single)">
            <summary>
            Set limit/motor parameters for a universal joint
                        See http://ode.org/ode-latest-userguide.html#sec_7_5_1 for details
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
            <param name="value">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetUniversalParam(System.IntPtr,System.Int32)">
            <summary>
            Get limit/motor parameters for a universal joint
                        See http://ode.org/ode-latest-userguide.html#sec_7_5_1 for details
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointAddUniversalTorques(System.IntPtr,System.Single,System.Single)">
            <summary>
            Applies torque1 about the universal's axis 1, and torque2 about the universal's axis 2.
            </summary>
            <remarks>
            This function is just a wrapper for dBodyAddTorque.
            </remarks>
            <param name="joint">A  dJointID</param>
            <param name="torque1">A  dReal</param>
            <param name="torque2">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetFixed(System.IntPtr)">
            <summary>
            Call this on the fixed joint after it has been attached to remember the current desired
            relative offset and desired relative rotation between the bodies.
            </summary>
            <remarks>
            The fixed joint maintains a fixed relative position and orientation between two bodies,
            or between a body and the static environment.
            Using this joint is almost never a good idea in practice, except when debugging.
            If you need two bodies to be glued together it is better to represent that as a single body.
            </remarks>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetAMotorMode(System.IntPtr,System.Int32)">
            <summary>
            Set the angular motor mode.
            The mode parameter must be one of the following constants:
            	dAMotorUser:	The AMotor axes and joint angle settings are entirely controlled by the user.
            					This is the default mode.
            	dAMotorEuler:	Euler angles are automatically computed.
            					The axis a1 is also automatically computed.
            					The AMotor axes must be set correctly when in this mode, as described below.
            					When this mode is initially set the current relative orientations of the
            					bodies will correspond to all euler angles at zero.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="mode">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetAMotorMode(System.IntPtr)">
            <summary>
            Get the angular motor mode.
            The mode parameter will be one of the following constants:
            	dAMotorUser:	The AMotor axes and joint angle settings are entirely controlled by the user.
            					This is the default mode.
            	dAMotorEuler:	Euler angles are automatically computed.
            					The axis a1 is also automatically computed.
            					The AMotor axes must be set correctly when in this mode, as described below.
            					When this mode is initially set the current relative orientations of the
            					bodies will correspond to all euler angles at zero.
            </summary>
            <returns>An int</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetAMotorNumAxes(System.IntPtr,System.Int32)">
            <summary>
            Set the number of angular axes that will be controlled by the AMotor.
            The argument num can range from 0 (which effectively deactivates the joint) to 3.
            This is automatically set to 3 in dAMotorEuler mode.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="num">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetAMotorNumAxes(System.IntPtr)">
            <summary>
            Get the number of angular axes controlled by the AMotor.
            The number of axes can range from 0 (which effectively deactivates the joint) to 3.
            This is automatically set to 3 in dAMotorEuler mode.
            </summary>
            <returns>An int</returns>
            <param name="joint">A  dJointID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetAMotorAxis(System.IntPtr,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Set the AMotor axes.
            The anum argument selects the axis to change (0,1 or 2).
            Each axis can have one of three ``relative orientation'' modes, selected by rel:
            	*	0: The axis is anchored to the global frame.
            	*	1: The axis is anchored to the first body.
            	*	2: The axis is anchored to the second body.
                        The axis vector (x,y,z) is always specified in global coordinates regardless of the setting of rel.
                        For dAMotorEuler mode:
            	* Only axes 0 and 2 need to be set. Axis 1 will be determined automatically at each time step.
            	* Axes 0 and 2 must be perpendicular to each other.
            	* Axis 0 must be anchored to the first body, axis 2 must be anchored to the second body.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="anum">An int</param>
            <param name="rel">An int</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetAMotorAxis(System.IntPtr,System.Int32,Tao.Ode.Ode.dVector3@)">
            <summary>
            Get the specified AMotor axis.
            The anum argument selects the axis to get (0,1 or 2).
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="anum">An int</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetAMotorAxisRel(System.IntPtr,System.Int32)">
            <summary>
            Get the relative orientation mode for the specified axis
            The anum argument selects the axis to get (0,1 or 2).
            The return value will represent one of three ``relative orientation'' modes:
            	*	0: The axis is anchored to the global frame.
            	*	1: The axis is anchored to the first body.
            	*	2: The axis is anchored to the second body.
            </summary>
            <returns>An int</returns>
            <param name="joint">A  dJointID</param>
            <param name="anum">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetAMotorAngle(System.IntPtr,System.Int32,System.Single)">
            <summary>
            Tell the AMotor what the current angle is along axis anum.
            This function should only be called in dAMotorUser mode, because in this mode
            the AMotor has no other way of knowing the joint angles.
            The angle information is needed if stops have been set along the axis,
            but it is not needed for axis motors.
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="anum">An int</param>
            <param name="angle">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetAMotorAngle(System.IntPtr,System.Int32)">
            <summary>
            Return the current angle for axis anum.
            In dAMotorUser mode this is simply the value that was set with dJointSetAMotorAngle.
            In dAMotorEuler mode this is the corresponding euler angle.
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
            <param name="anum">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetAMotorAngleRate(System.IntPtr,System.Int32)">
            <summary>
            Return the current angle rate for axis anum.
            In dAMotorUser mode this is always zero, as not enough information is available.
            In dAMotorEuler mode this is the corresponding euler angle rate.
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
            <param name="anum">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointSetAMotorParam(System.IntPtr,System.Int32,System.Single)">
            <summary>
            Set limit/motor parameters for a an angular motor joint
                        See http://ode.org/ode-latest-userguide.html#sec_7_5_1 for details
            </summary>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
            <param name="value">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointGetAMotorParam(System.IntPtr,System.Int32)">
            <summary>
            Get limit/motor parameters for a an angular motor joint
                        See http://ode.org/ode-latest-userguide.html#sec_7_5_1 for details
            </summary>
            <returns>A dReal</returns>
            <param name="joint">A  dJointID</param>
            <param name="parameter">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dJointAddAMotorTorques(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Applies torque0 about the AMotor's axis 0,
            torque1 about the AMotor's axis 1,
            and torque2 about the AMotor's axis 2.
            If the motor has fewer than three axes, the higher torques are ignored.
            </summary>
            <remarks>
            This function is just a wrapper for dBodyAddTorque.
            </remarks>
            <param name="joint">A  dJointID</param>
            <param name="torque1">A  dReal</param>
            <param name="torque2">A  dReal</param>
            <param name="torque3">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetZero(Tao.Ode.Ode.dMass@)">
            <summary>
            Set all the mass parameters to zero
            </summary>
            <param name="mass">A reference to a dMass</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetParameters(Tao.Ode.Ode.dMass@,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Set the mass parameters to the given values.
            </summary>
            <remarks>
            The inertia matrix looks like this:
                [ I11 I12 I13 ]
                [ I12 I22 I23 ]
                [ I13 I23 I33 ]
            </remarks>
            <param name="mass">A reference to a dMass</param>
            <param name="themass">the mass of the body</param>
            <param name="cgx">the x coordinate for the center of gravity position in the body frame</param>
            <param name="cgy">the y coordinate for the center of gravity position in the body frame</param>
            <param name="cgz">the z coordinate for the center of gravity position in the body frame</param>
            <param name="I11">An element of the inertia matrix</param>
            <param name="I22">An element of the inertia matrix</param>
            <param name="I33">An element of the inertia matrix</param>
            <param name="I12">An element of the inertia matrix</param>
            <param name="I13">An element of the inertia matrix</param>
            <param name="I23">An element of the inertia matrix</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetSphere(Tao.Ode.Ode.dMass@,System.Single,System.Single)">
            <summary>
            Set the mass parameters to represent a sphere of the given radius and density, with
            the center of mass at (0,0,0) relative to the body.
            </summary>
            <param name="mass">A  dMass</param>
            <param name="density">A  dReal</param>
            <param name="radius">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetSphereTotal(Tao.Ode.Ode.dMass@,System.Single,System.Single)">
            <summary>
            Set the mass parameters to represent a sphere of the given total mass and radius, with
            the center of mass at (0,0,0) relative to the body.
            </summary>
            <param name="mass">A  dMass</param>
            <param name="total_mass">A  dReal</param>
            <param name="radius">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetCappedCylinder(Tao.Ode.Ode.dMass@,System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Set the mass parameters to represent a capped cylinder of the given parameters and density, with
            the center of mass at (0,0,0) relative to the body.
            </summary>
            <remarks>
            The cylinder's long axis is oriented along the body's x, y or z axis according to the value of direction (1=x, 2=y, 3=z).
            </remarks>
            <param name="mass">A  dMass</param>
            <param name="density">The density of the cylinder</param>
            <param name="direction">The orientation of the cylinder's long axis (1=x, 2=y, 3=z)</param>
            <param name="radius">The radius of the cylinder (and the spherical cap)</param>
            <param name="length">The length of the cylinder (not counting the spherical cap)</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetCappedCylinderTotal(Tao.Ode.Ode.dMass@,System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Set the mass parameters to represent a capped cylinder of the given parameters and total mass, with
            the center of mass at (0,0,0) relative to the body.
            </summary>
            <remarks>
            The cylinder's long axis is oriented along the body's x, y or z axis according to the value of direction (1=x, 2=y, 3=z).
            </remarks>
            <param name="mass">A  dMass</param>
            <param name="total_mass">The total mass of the cylinder</param>
            <param name="direction">The orientation of the cylinder's long axis (1=x, 2=y, 3=z)</param>
            <param name="radius">The radius of the cylinder (and the spherical cap)</param>
            <param name="length">The length of the cylinder (not counting the spherical cap)</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetCylinder(Tao.Ode.Ode.dMass@,System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Set the mass parameters to represent a flat-ended cylinder of the given parameters and density, with
            the center of mass at (0,0,0) relative to the body.
            </summary>
            <remarks>
            The cylinder's long axis is oriented along the body's x, y or z axis according to the value of direction (1=x, 2=y, 3=z).
            </remarks>
            <param name="mass">A  dMass</param>
            <param name="density">A  dReal</param>
            <param name="direction">An int</param>
            <param name="radius">The radius of the cylinder</param>
            <param name="length">The length of the cylinder</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetCylinderTotal(Tao.Ode.Ode.dMass@,System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Set the mass parameters to represent a flat-ended cylinder of the given parameters and total mass, with
            the center of mass at (0,0,0) relative to the body.
            </summary>
            <remarks>
            The cylinder's long axis is oriented along the body's x, y or z axis according to the value of direction (1=x, 2=y, 3=z).
            </remarks>
            <param name="mass">A  dMass</param>
            <param name="total_mass">A  dReal</param>
            <param name="direction">An int</param>
            <param name="radius">The radius of the cylinder</param>
            <param name="length">The length of the cylinder</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetBox(Tao.Ode.Ode.dMass@,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Set the mass parameters to represent a box of the given dimensions and density, with
            the center of mass at (0,0,0) relative to the body.
            </summary>
            <param name="mass">A  dMass</param>
            <param name="density">The density of the box</param>
            <param name="lx">The side length of the box along the x axis</param>
            <param name="ly">The side length of the box along the y axis</param>
            <param name="lz">The side length of the box along the z axis</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassSetBoxTotal(Tao.Ode.Ode.dMass@,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Set the mass parameters to represent a box of the given dimensions and total mass, with
            the center of mass at (0,0,0) relative to the body.
            </summary>
            <param name="mass">A  dMass</param>
            <param name="total_mass">The total mass of the box</param>
            <param name="lx">The side length of the box along the x axis</param>
            <param name="ly">The side length of the box along the y axis</param>
            <param name="lz">The side length of the box along the z axis</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassAdjust(Tao.Ode.Ode.dMass@,System.Single)">
            <summary>
            Given mass parameters for some object, adjust them so the total mass is now newmass
            </summary>
            <remarks>
            This is useful when using the "mass set" functions to set the mass parameters for
            certain objects - they take the object density, not the total mass.
            </remarks>
            <param name="mass">A  dMass</param>
            <param name="newmass">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassTranslate(Tao.Ode.Ode.dMass@,System.Single,System.Single,System.Single)">
            <summary>
            Given mass parameters for some object, adjust them to represent the object displaced
            by (x,y,z) relative to the body frame.
            </summary>
            <param name="mass">A  dMass</param>
            <param name="x">The displacement along the x axis</param>
            <param name="y">The displacement along the y axis</param>
            <param name="z">The displacement along the z axis</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassRotate(Tao.Ode.Ode.dMass@,Tao.Ode.Ode.dMatrix3)">
            <summary>
            Given mass parameters for some object, adjust them to represent the object rotated by R relative to the body frame.
            </summary>
            <param name="mass">A  dMass</param>
            <param name="R">A  dMatrix3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dMassAdd(Tao.Ode.Ode.dMass@,Tao.Ode.Ode.dMass)">
            <summary>
            Add the mass b to the mass a.
            </summary>
            <remarks>
            Should mass b be a reference as well?
            </remarks>
            <param name="a">A  dMass</param>
            <param name="b">A  dMass</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomDestroy(System.IntPtr)">
            <summary>
            Destroy a geom, removing it from any space it is in first. 
            This one function destroys a geom of any type, but to create a geom you 
            must call a creation function for that type.
            When a space is destroyed, if its cleanup mode is 1 (the default) then 
            all the geoms in that space are automatically destroyed as well.
            </summary>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSetData(System.IntPtr,System.IntPtr)">
            <summary>
            Set the user-defined data pointer stored in the geom.
                        WARNING: It is unclear from the ODE source and the documentation what the nature of
            user-data is.
            This function is here for the sake of completeness because it is part of ODE's public API, but
            has NOT been tested in any way.
                        Use at own risk.
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="data">An IntPtr</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomGetData(System.IntPtr)">
            <summary>
            Get the user-defined data pointer stored in the geom.
                        WARNING: It is unclear from the ODE source and the documentation what the nature of
            user-data is.
            This function is here for the sake of completeness because it is part of ODE's public API, but
            has NOT been tested in any way.
                        Use at own risk.
            </summary>
            <returns>A void*</returns>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSetBody(System.IntPtr,System.IntPtr)">
            <summary>
            Set the body associated with a placeable geom. 
            
            Setting a body on a geom automatically combines the position vector and 
            rotation matrix of the body and geom, so that setting the position or 
            orientation of one will set the value for both objects.
            Setting a body ID of zero gives the geom its own position and rotation, 
            independent from any body. 
            If the geom was previously connected to a body then its new independent 
            position/rotation is set to the current position/rotation of the body.
            
            Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomGetBody(System.IntPtr)">
            <summary>
            Get the body associated with at placeable geom.
            
            Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.
            </summary>
            <returns>A dBodyID</returns>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSetPosition(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the position vector of a placeable geom. 
            
            This function is analogous to dBodySetPosition.
             
            If the geom is attached to a body, the body's position will also be changed.
            
            Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSetRotation(System.IntPtr,Tao.Ode.Ode.dMatrix3)">
            <summary>
            Set the rotation matrix of a placeable geom. 
            
            This function is analogous to dBodySetRotation.
             
            If the geom is attached to a body, the body's rotation will also be changed.
            
            Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="R">A  dMatrix3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSetQuaternion(System.IntPtr,Tao.Ode.Ode.dQuaternion)">
            <summary>
            Set the quaternion of a placeable geom. 
            
            This function is analogous to dBodySetQuaternion. 
            
            If the geom is attached to a body, the body's quaternion will also be changed.
            
            Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="q">A  dQuaternion</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomGetPosition(System.IntPtr)">
            <summary>
            Return the geom's position vector. 
            
            In native ODE, the returned values are pointers to internal data 
            structures, so the vectors are valid until any changes are made to the 
            geom. 
            
            If the geom is attached to a body, the body's position vector will be 
            returned, i.e. the result will be identical to calling dBodyGetPosition
            
            dGeomGetQuaternion copies the geom's quaternion into the space provided. 
            If the geom is attached to a body, the body's quaternion will be returned, 
            i.e. the resulting quaternion will be the same as the result of calling dBodyGetQuaternion.
            
            Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.
            </summary>
            <returns>A dVector3</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomGetRotation(System.IntPtr)">
            <summary>
            Return the geom's rotation vector.
            
            In native ODE, the returned values are pointers to internal data 
            structures, so the vectors are valid until any changes are made to the 
            geom. 
            
            If the geom is attached to a body, the body's rotation vector will be 
            returned, i.e. the result will be identical to calling dBodyGetRotation.
            
            Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.
            </summary>
            <returns>A dVector3</returns>
            <param name="body">A  dBodyID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomGetQuaternion(System.IntPtr,Tao.Ode.Ode.dQuaternion@)">
            <summary>
            Get the geom's quaternion.
            
            dGeomGetQuaternion copies the geom's quaternion into the structure provided. 
            
            If the geom is attached to a body, the body's quaternion will be returned, 
            i.e. the resulting quaternion will be the same as the result of calling dBodyGetQuaternion.
            
            Calling this function on a non-placeable geom results in a runtime error in the debug build of ODE.
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="result">A  dQuaternion</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomGetAABB(System.IntPtr,Tao.Ode.Ode.Aabb)">
            <summary>
            Return in aabb an axis aligned bounding box that surrounds the given geom. 
            
            The aabb array has elements (minx, maxx, miny, maxy, minz, maxz).
             
            If the geom is a space, a bounding box that surrounds all contained geoms is returned.
            
            This function may return a pre-computed cached bounding box, if it can 
            determine that the geom has not moved since the last time the bounding box was computed.
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="aabb">An Aabb</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomIsSpace(System.IntPtr)">
            <summary>
            Return 1 if the given geom is a space, or 0 if not.		
            </summary>
            <returns>An int</returns>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomGetSpace(System.IntPtr)">
            <summary>
            Return the space that the given geometry is contained in, or return 0 if it is not contained in any space.
            </summary>
            <returns>A dSpaceID</returns>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomGetClass(System.IntPtr)">
            <summary>
            Given a geom, this returns its class number. The standard class numbers are:
            	dSphereClass  			Sphere
            	dBoxClass  				Box
            	dCCylinderClass			Capped cylinder
            	dCylinderClass  		Regular flat-ended cylinder
            	dPlaneClass  			Infinite plane (non-placeable)
            	dGeomTransformClass 	Geometry transform
            	dRayClass  				Ray
            	dTriMeshClass  			Triangle mesh
            	dSimpleSpaceClass  		Simple space
            	dHashSpaceClass  		Hash table based space
            
            User defined classes will return their own numbers.
            </summary>
            <returns>An int</returns>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSetCategoryBits(System.IntPtr,System.UInt64)">
            <summary>
            Set the ``category'' bitfield for the given geom. 
            This bitfield is used by spaces to govern which geoms will interact 
            with each other. 
            
            The bit fields are guaranteed to be at least 32 bits wide. 
            
            The default category and collide values for newly created geoms have all bits set.
                        Note this is NOT CLS-compliant (due to the use of ulong to hold the 32-bit bitfield)
            TODO: Implement a CLS-compliant work-around or justify why not
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="bits">An ulong</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSetCollideBits(System.IntPtr,System.UInt64)">
            <summary>
            Set the ``collide'' bitfield for the given geom. 
            
            This bitfield is used by spaces to govern which geoms will interact 
            with each other. 
            
            The bit fields are guaranteed to be at least 32 bits wide. 
            
            The default category and collide values for newly created geoms have all bits set.
                        Note this is NOT CLS-compliant (due to the use of ulong to hold the 32-bit bitfield)
            TODO: Implement a CLS-compliant work-around or justify why not
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="bits">An ulong</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Tao.Ode.Ode.dGeomGetCategoryBits(System.IntPtr)" -->
        <member name="M:Tao.Ode.Ode.dGeomGetCollideBits(System.IntPtr)">
            <summary>
            Get the ``collide'' bitfield for the given geom. 
            This bitfield is used by spaces to govern which geoms will interact 
            with each other. 
            
            The bit fields are guaranteed to be at least 32 bits wide. 
            
            The default category and collide values for newly created geoms have all bits set.
                        Note this is NOT CLS-compliant (due to the use of ulong to hold the 32-bit bitfield)
            TODO: Implement a CLS-compliant work-around or justify why not
            </summary>
            <returns>An ulong</returns>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomEnable(System.IntPtr)">
            <summary>
            Enable a geom. 
            
            Disabled geoms are completely ignored by dSpaceCollide and dSpaceCollide2,
            although they can still be members of a space.
            
            New geoms are created in the enabled state.
            </summary>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomDisable(System.IntPtr)">
            <summary>
            Disable a geom. 
            
            Disabled geoms are completely ignored by dSpaceCollide and dSpaceCollide2,
            although they can still be members of a space.
            
            New geoms are created in the enabled state.
            </summary>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomIsEnabled(System.IntPtr)">
            <summary>
            Returns 1 if a geom is enabled or 0 if it is disabled. 
            
            New geoms are created in the enabled state.
            </summary>
            <returns>An int</returns>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCollide(System.IntPtr,System.IntPtr,System.Int32,Tao.Ode.Ode.dContactGeom[],System.Int32)">
            <summary>
            Given two geoms o1 and o2 that potentially intersect, generate contact 
            information for them. 
            
            Internally, this just calls the correct class-specific collision functions
            for o1 and o2.
            
            "flags" specifies how contacts should be generated if the geoms touch. The 
            lower 16 bits of flags is an integer that specifies the maximum number 
            of contact points to generate. Note that if this number is zero, this 
            function just pretends that it is one - in other words you can not ask 
            for zero contacts. All other bits in flags must be zero. 
            In the future the other bits may be used to select from different contact 
            generation strategies.
            
            "contacts" points to an array of dContactGeom structures. The array must 
            be able to hold at least the maximum number of contacts. These 
            dContactGeom structures may be embedded within larger structures in the 
            array - the skip parameter is the byte offset from one dContactGeom to 
            the next in the array. If skip is sizeof(dContactGeom) then contact 
            points to a normal (C-style) array. It is an error for skip to be smaller
            than sizeof(dContactGeom).
            
            If the geoms intersect, this function returns the number of contact points
            generated (and updates the contact array), otherwise it returns 0 (and the
             contact array is not touched).
            
            If a space is passed as o1 or o2 then this function will collide all 
            objects contained in o1 with all objects contained in o2, and return 
            the resulting contact points. This method for colliding spaces with 
            geoms (or spaces with spaces) provides no user control over the 
            individual collisions. To get that control, use dSpaceCollide or 
            dSpaceCollide2 instead.
            
            If o1 and o2 are the same geom then this function will do nothing and 
            return 0. Technically speaking an object intersects with itself, but 
            it is not useful to find contact points in this case.
            
            This function does not care if o1 and o2 are in the same space or not 
            (or indeed if they are in any space at all).
            </summary>
            <returns>An int</returns>
            <param name="o1">A  dGeomID</param>
            <param name="o2">A  dGeomID</param>
            <param name="flags">An int</param>
            <param name="contacts">A  dContactGeom[]</param>
            <param name="skip">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceCollide(System.IntPtr,System.IntPtr,Tao.Ode.Ode.dNearCallback)">
            <summary>
            This determines which pairs of geoms in a space may potentially intersect,
            and calls the callback function with each candidate pair. 
            
            The callback function is of type dNearCallback, which is defined as: 
            	typedef void dNearCallback (void *data, dGeomID o1, dGeomID o2);
            
            The data argument is passed from dSpaceCollide directly to the callback 
            function. Its meaning is user defined. 
            The o1 and o2 arguments are the geoms that may be near each other.
            The callback function can call dCollide on o1 and o2 to generate contact 
            points between each pair. Then these contact points may be added to the 
            simulation as contact joints. The user's callback function can of course 
            chose not to call dCollide for any pair, e.g. if the user decides that 
            those pairs should not interact.
            
            Other spaces that are contained within the colliding space are not treated 
            specially, i.e. they are not recursed into. The callback function may be 
            passed these contained spaces as one or both geom arguments.
            
            dSpaceCollide() is guaranteed to pass all intersecting geom pairs to the 
            callback function, but it may also make mistakes and pass non-intersecting 
            pairs. The number of mistaken calls depends on the internal algorithms 
            used by the space. Thus you should not expect that dCollide will return 
            contacts for every pair passed to the callback.
            </summary>
            <param name="space">A  dSpaceID</param>
            <param name="data">An IntPtr</param>
            <param name="callback">A  dNearCallback</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceCollide2(System.IntPtr,System.IntPtr,System.IntPtr,Tao.Ode.Ode.dNearCallback)">
            <summary>
            This function is similar to dSpaceCollide, except that it is passed two 
            geoms (or spaces) as arguments. It calls the callback for all 
            potentially intersecting pairs that contain one geom from o1 and one geom 
            from o2.
            
            The exact behavior depends on the types of o1 and o2: 
            	If one argument is a non-space geom and the other is a space, the 
            	callback is called with all potential intersections between the geom and 
            	the objects in the space.
            	If both o1 and o2 are spaces then this calls the callback for all potentially 
            	intersecting pairs that contain one geom from o1 and one geom from o2. The 
            	algorithm that is used depends on what kinds of spaces are being collided. 
            	If no optimized algorithm can be selected then this function will resort 
            	to one of the following two strategies: 
            		1. 	All the geoms in o1 are tested one-by-one against o2. 
            		2. 	All the geoms in o2 are tested one-by-one against o1. 
            	The strategy used may depend on a number of rules, but in general the 
            	space with less objects has its geoms examined one-by-one. 
            		-	If both arguments are the same space, this is equivalent to calling 
            			dSpaceCollide on that space. 
            		-	If both arguments are non-space geoms, this simply calls the callback 
            			once with these arguments. 
            
            If this function is given a space and an geom X in that same space, this 
            case is not treated specially. In this case the callback will always be 
            called with the pair (X,X), because an objects always intersects with 
            itself. The user may either test for this case and ignore it, or just 
            pass the pair (X,X) to dCollide (which will be guaranteed to return 0).
            </summary>
            <param name="o1">A  dGeomID</param>
            <param name="o2">A  dGeomID</param>
            <param name="data">An IntPtr</param>
            <param name="callback">A  dNearCallback</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCreateSphere(System.IntPtr,System.Single)">
            <summary>
            Create a sphere geom of the given radius, and return its ID. If space is 
            nonzero, insert it into that space. The point of reference for a sphere 
            is its center.
            </summary>
            <returns>A dGeomID</returns>
            <param name="space">A  dSpaceID</param>
            <param name="radius">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSphereSetRadius(System.IntPtr,System.Single)">
            <summary>
            Set the radius of the given sphere.
            </summary>
            <param name="sphere">A  dGeomID</param>
            <param name="radius">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSphereGetRadius(System.IntPtr)">
            <summary>
            Return the radius of the given sphere.
            </summary>
            <returns>A dReal</returns>
            <param name="sphere">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomSpherePointDepth(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Return the depth of the point (x,y,z) in the given sphere. 
            
            Points inside the geom will have positive depth, points outside it will 
            have negative depth, and points on the surface will have zero depth.
            </summary>
            <returns>A dReal</returns>
            <param name="sphere">A  dGeomID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCreateBox(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Create a box geom of the given x/y/z side lengths (lx,ly,lz), and return 
            its ID. 
            
            If space is nonzero, insert it into that space. The point of reference 
            for a box is its center.
            </summary>
            <returns>A dGeomID</returns>
            <param name="space">A  dSpaceID</param>
            <param name="lx">A  dReal</param>
            <param name="ly">A  dReal</param>
            <param name="lz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomBoxSetLengths(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Set the side lengths of the given box.
            </summary>
            <param name="box">A  dGeomID</param>
            <param name="lx">A  dReal</param>
            <param name="ly">A  dReal</param>
            <param name="lz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomBoxGetLengths(System.IntPtr,Tao.Ode.Ode.dVector3@)">
            <summary>
            Return in result the side lengths of the given box.
            </summary>
            <param name="box">A  dGeomID</param>
            <param name="result">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomBoxPointDepth(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Return the depth of the point (x,y,z) in the given box. 
            
            Points inside the geom will have positive depth, points outside it will 
            have negative depth, and points on the surface will have zero depth.
            </summary>
            <returns>A dReal</returns>
            <param name="box">A  dGeomID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCreatePlane(System.IntPtr,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create a plane geom of the given parameters, and return its ID. 
            
            If space is nonzero, insert it into that space. The plane equation is 
            	a*x+b*y+c*z = d
            
            The plane's normal vector is (a,b,c), and it must have length 1. 
            
            Planes are non-placeable geoms. This means that, unlike placeable geoms, 
            planes do not have an assigned position and rotation. This means that 
            the parameters (a,b,c,d) are always in global coordinates. In other words 
            it is assumed that the plane is always part of the static environment and 
            not tied to any movable object.
            </summary>
            <returns>A dGeomID</returns>
            <param name="space">A  dSpaceID</param>
            <param name="a">A  dReal</param>
            <param name="b">A  dReal</param>
            <param name="c">A  dReal</param>
            <param name="d">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomPlaneSetParams(System.IntPtr,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Set the parameters of the given plane.
            </summary>
            <param name="plane">A  dGeomID</param>
            <param name="a">A  dReal</param>
            <param name="b">A  dReal</param>
            <param name="c">A  dReal</param>
            <param name="d">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomPlaneGetParams(System.IntPtr,Tao.Ode.Ode.dVector4@)">
            <summary>
            Return in result the parameters of the given plane.
            </summary>
            <param name="plane">A  dGeomID</param>
            <param name="result">A  dVector4</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomPlanePointDepth(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Return the depth of the point (x,y,z) in the given plane. 
            
            Points inside the geom will have positive depth, points outside it will 
            have negative depth, and points on the surface will have zero depth.
            </summary>
            <returns>A dReal</returns>
            <param name="plane">A  dGeomID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCreateCCylinder(System.IntPtr,System.Single,System.Single)">
            <summary>
            Create a capped cylinder geom of the given parameters, and return its ID. 
            If space is nonzero, insert it into that space.
            
            A capped cylinder is like a normal cylinder except it has half-sphere 
            caps at its ends. This feature makes the internal collision detection 
            code particularly fast and accurate. The cylinder's length, not counting 
            the caps, is given by length. The cylinder is aligned along the geom's 
            local Z axis. The radius of the caps, and of the cylinder itself, is 
            given by radius.
            </summary>
            <returns>A dGeomID</returns>
            <param name="space">A  dSpaceID</param>
            <param name="radius">A  dReal</param>
            <param name="length">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomCCylinderSetParams(System.IntPtr,System.Single,System.Single)">
            <summary>
            Set the parameters of the given capped cylinder.
            </summary>
            <param name="ccylinder">A  dGeomID</param>
            <param name="radius">A  dReal</param>
            <param name="length">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomCCylinderGetParams(System.IntPtr,System.Single@,System.Single@)">
            <summary>
            Return in radius and length the parameters of the given capped cylinder.
            </summary>
            <param name="ccylinder">A  dGeomID</param>
            <param name="radius">A  dReal</param>
            <param name="length">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomCCylinderPointDepth(System.IntPtr,System.Single,System.Single,System.Single)">
            <summary>
            Return the depth of the point (x,y,z) in the given capped cylinder. 
            
            Points inside the geom will have positive depth, points outside it will 
            have negative depth, and points on the surface will have zero depth.
            </summary>
            <returns>A dReal</returns>
            <param name="ccylinder">A  dGeomID</param>
            <param name="x">A  dReal</param>
            <param name="y">A  dReal</param>
            <param name="z">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCreateRay(System.IntPtr,System.Single)">
            <summary>
            Create a ray geom of the given length, and return its ID. 
            
            If space is nonzero, insert it into that space.
            </summary>
            <remarks>
            A ray is different from all the other geom classes in that it does not 
            represent a solid object. It is an infinitely thin line that starts from 
            the geom's position and extends in the direction of the geom's local Z-axis.
            
            Calling dCollide between a ray and another geom will result in at most one 
            contact point. Rays have their own conventions for the contact information 
            in the dContactGeom structure (thus it is not useful to create contact 
            joints from this information):
            
            	pos - 		This is the point at which the ray intersects the surface of the 
            				other geom, regardless of whether the ray starts from inside or 
            				outside the geom.
            	normal - 	This is the surface normal of the other geom at the contact point. 
            				if dCollide is passed the ray as its first geom then the normal 
            				will be oriented correctly for ray reflection from that surface 
            				(otherwise it will have the opposite sign).
            	depth - 	This is the distance from the start of the ray to the contact point. 
            
            Rays are useful for things like visibility testing, determining the path of 
            projectiles or light rays, and for object placement.
            </remarks>
            <returns>A dGeomID</returns>
            <param name="space">A  dSpaceID</param>
            <param name="length">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRaySetLength(System.IntPtr,System.Single)">
            <summary>
            Set the length of the given ray.
            </summary>
            <param name="ray">A  dGeomID</param>
            <param name="length">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRayGetLength(System.IntPtr)">
            <summary>
            Get the length of the given ray.
            </summary>
            <returns>A dReal</returns>
            <param name="ray">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRaySet(System.IntPtr,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Set the starting position (px,py,pz) and direction (dx,dy,dz) of the given ray. 
            The ray's rotation matrix will be adjusted so that the local Z-axis is aligned 
            with the direction. 
            
            Note that this does not adjust the ray's length.
            </summary>
            <param name="ray">A  dGeomID</param>
            <param name="px">A  dReal</param>
            <param name="py">A  dReal</param>
            <param name="pz">A  dReal</param>
            <param name="dx">A  dReal</param>
            <param name="dy">A  dReal</param>
            <param name="dz">A  dReal</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRayGet(System.IntPtr,Tao.Ode.Ode.dVector3,Tao.Ode.Ode.dVector3)">
            <summary>
            Get the starting position (start) and direction (dir) of the ray. 
            The returned direction will be a unit length vector.
            </summary>
            <param name="ray">A  dGeomID</param>
            <param name="start">A  dVector3</param>
            <param name="dir">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRaySetParams(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Method dGeomRaySetParams
            TODO: Document me
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="FirstContact">An int</param>
            <param name="BackfaceCull">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRayGetParams(System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
            Method dGeomRayGetParams
            TODO: Document me
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="FirstContact">An int</param>
            <param name="BackfaceCull">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRayGetParams(System.IntPtr,System.Int32[],System.Int32[])">
            <summary>
            Method dGeomRayGetParams
            TODO: Document me
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="FirstContact">An int[]</param>
            <param name="BackfaceCull">An int[]</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRaySetClosestHit(System.IntPtr,System.Int32)">
            <summary>
            Method dGeomRaySetClosestHit
            TODO: Document me
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="closestHit">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomRayGetClosestHit(System.IntPtr)">
            <summary>
            Method dGeomRayGetClosestHit
            TODO: Document me
            </summary>
            <returns>An int</returns>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCreateGeomTransform(System.IntPtr)">
            <summary>
            Create a new geometry transform object, and return its ID. 
            If space is nonzero, insert it into that space. 
            On creation the encapsulated geometry is set to 0.
            </summary>
            <remarks>
            A geometry transform `T' is a geom that encapsulates another geom `E', 
            allowing E to be positioned and rotated arbitrarily with respect to 
            its point of reference.
            Most placeable geoms (like the sphere and box) have their point of 
            reference corresponding to their center of mass, allowing them to be 
            easily connected to dynamics objects. Transform objects give you more 
            flexibility - for example, you can offset the center of a sphere, or 
            rotate a cylinder so that its axis is something other than the default.
            T mimics the object E that it encapsulates: T is inserted into a space 
            and attached to a body as though it was E. E itself must not be inserted 
            into a space or attached to a body. E's position and rotation are set to 
            constant values that say how it is transformed relative to T. If E's 
            position and rotation are left at their default values, T will behave 
            exactly like E would have if you had used it directly.
            </remarks>
            <returns>A dGeomID</returns>
            <param name="space">A  dSpaceID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTransformSetGeom(System.IntPtr,System.IntPtr)">
            <summary>
            Set the geom that the geometry transform g encapsulates. The object obj 
            must not be inserted into any space, and must not be associated with any body.
            
            If g has its clean-up mode turned on, and it already encapsulates an object, 
            the old object will be destroyed before it is replaced with the new one.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="obj">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTransformGetGeom(System.IntPtr)">
            <summary>
            Get the geom that the geometry transform g encapsulates.
            </summary>
            <returns>A dGeomID</returns>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTransformSetCleanup(System.IntPtr,System.Int32)">
            <summary>
            Set the clean-up mode of geometry transform g. 
            
            If the clean-up mode is 1, then the encapsulated object will be destroyed 
            when the geometry transform is destroyed. 
            If the clean-up mode is 0 this does not happen. 
            
            The default clean-up mode is 0.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="mode">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTransformGetCleanup(System.IntPtr)">
            <summary>
            Get the clean-up mode of geometry transform g. 
            
            If the clean-up mode is 1, then the encapsulated object will be destroyed 
            when the geometry transform is destroyed. 
            If the clean-up mode is 0 this does not happen. 
            
            The default clean-up mode is 0.
            </summary>
            <returns>An int</returns>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTransformSetInfo(System.IntPtr,System.Int32)">
            <summary>
            Set and get the "information" mode of geometry transform g. 
            
            The mode can be 0 or 1. The default mode is 0.
            With mode 0, when a transform object is collided with another object 
            (using dCollide (tx_geom,other_geom,...)), the g1 field of the 
            dContactGeom structure is set to the geom that is encapsulated by the 
            transform object. This value of g1 allows the caller to interrogate the 
            type of the geom that is transformed, but it does not allow the caller 
            to determine the position in global coordinates or the associated body, 
            as both of these properties are used differently for encapsulated geoms.
            With mode 1, the g1 field of the dContactGeom structure is set to the 
            transform object itself. This makes the object appear just like any other 
            kind of geom, as dGeomGetBody will return the attached body, and 
            dGeomGetPosition will return the global position. 
            To get the actual type of the encapsulated geom in this case, 
            dGeomTransformGetGeom must be used.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="mode">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTransformGetInfo(System.IntPtr)">
            <summary>
            Set and get the "information" mode of geometry transform g. 
            
            The mode can be 0 or 1. The default mode is 0.
            </summary>
            <returns>An int</returns>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dClosestLineSegmentPoints(Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dVector3@)">
            <summary>
            Given two line segments A and B with endpoints a1-a2 and b1-b2, return 
            the points on A and B that are closest to each other (in cp1 and cp2). 
            
            In the case of parallel lines where there are multiple solutions, a 
            solution involving the endpoint of at least one line will be returned. 
            This will work correctly for zero length lines, e.g. if a1==a2 and/or b1==b2.
            </summary>
            <param name="a1">A  dVector3</param>
            <param name="a2">A  dVector3</param>
            <param name="b1">A  dVector3</param>
            <param name="b2">A  dVector3</param>
            <param name="cp1">A  dVector3</param>
            <param name="cp2">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dBoxTouchesBox(Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dMatrix3@,Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dMatrix3@,Tao.Ode.Ode.dVector3@)">
            <summary>
            Given boxes (p1,R1,side1) and (p2,R2,side2), return 1 if they intersect 
            or 0 if not. p is the center of the box, R is the rotation matrix for 
            the box, and side is a vector of x/y/z side lengths.
            </summary>
            <returns>An int</returns>
            <param name="_p1">A  dVector3</param>
            <param name="R1">A  dMatrix3</param>
            <param name="side1">A  dVector3</param>
            <param name="_p2">A  dVector3</param>
            <param name="R2">A  dMatrix3</param>
            <param name="side2">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dInfiniteAABB(System.IntPtr,Tao.Ode.Ode.Aabb)">
            <summary>
            This function can be used as the AABB-getting function in a geometry class, 
            if you don't want to compute tight bounds for the AABB. 
            It returns +/- infinity in each direction.
            </summary>
            <param name="geom">A  dGeomID</param>
            <param name="aabb">An Aabb</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCloseODE">
            <summary>
            This deallocates some extra memory used by ODE that can not be deallocated using the normal destroy functions,
            e.g. dWorldDestroy.
            You can use this function at the end of your application to prevent memory leak checkers from complaining about ODE.
            </summary>
        </member>
        <member name="M:Tao.Ode.Ode.dSimpleSpaceCreate(System.IntPtr)">
            <summary>
            Create a simple space. 
            
            If space is nonzero, insert the new space into that space.
            </summary>
            <returns>A dSpaceID</returns>
            <param name="space">A  dSpaceID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dHashSpaceCreate(System.IntPtr)">
            <summary>
            Create a multi-resolution hash table space. 
            
            If space is nonzero, insert the new space into that space.
            </summary>
            <returns>A dSpaceID</returns>
            <param name="space">A  dSpaceID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dQuadTreeSpaceCreate(System.IntPtr,Tao.Ode.Ode.dVector3,Tao.Ode.Ode.dVector3,System.Int32)">
            <summary>
            Creates a quadtree space. 
            
            Center and Extents define the size of the root block. 
            Depth sets the depth of the tree - the number of blocks that are created is 4^Depth
            </summary>
            <returns>A dSpaceID</returns>
            <param name="space">A  dSpaceID</param>
            <param name="Center">A  dVector3</param>
            <param name="Extents">A  dVector3</param>
            <param name="Depth">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceDestroy(System.IntPtr)">
            <summary>
            This destroys a space. 
            It functions exactly like dGeomDestroy except that it takes a dSpaceID argument. 
            When a space is destroyed, if its cleanup mode is 1 (the default) then all the 
            geoms in that space are automatically destroyed as well.
            </summary>
            <param name="space">A  dSpaceID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dHashSpaceSetLevels(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sets some parameters for a multi-resolution hash table space. 
            
            The smallest and largest cell sizes used in the hash table will be 
            2^minlevel and 2^maxlevel respectively. 
            
            minlevel must be less than or equal to maxlevel.
            </summary>
            <param name="space">A  dSpaceID</param>
            <param name="minlevel">An int</param>
            <param name="maxlevel">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dHashSpaceGetLevels(System.IntPtr,System.Int32@,System.Int32@)">
            <summary>
            Get some parameters for a multi-resolution hash table space. 
            
            The smallest and largest cell sizes used in the hash table will be 
            2^minlevel and 2^maxlevel respectively. 
            
            minlevel must be less than or equal to maxlevel.
            
            The minimum and maximum levels are returned through pointers. 
            If a pointer is zero then it is ignored and no argument is returned.
            </summary>
            <param name="space">A  dSpaceID</param>
            <param name="minlevel">An int</param>
            <param name="maxlevel">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceSetCleanup(System.IntPtr,System.Int32)">
            <summary>
            Set the clean-up mode of the space. 
            
            If the clean-up mode is 1, then the contained geoms will be destroyed 
            when the space is destroyed. 
            If the clean-up mode is 0 this does not happen. 
            
            The default clean-up mode for new spaces is 1.
            </summary>
            <param name="space">A  dSpaceID</param>
            <param name="mode">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceGetCleanup(System.IntPtr)">
            <summary>
            Get the clean-up mode of the space.
            </summary>
            <returns>An int</returns>
            <param name="space">A  dSpaceID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceAdd(System.IntPtr,System.IntPtr)">
            <summary>
            Add a geom to a space. 
            
            This does nothing if the geom is already in the space. 
            
            This function can be called automatically if a space argument is given to 
            a geom creation function.
            </summary>
            <param name="space">A  dSpaceID</param>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceRemove(System.IntPtr,System.IntPtr)">
            <summary>
            Remove a geom from a space. 
            
            This does nothing if the geom is not actually in the space. 
            
            This function is called automatically by dGeomDestroy if the geom is in a space.
            </summary>
            <param name="space">A  dSpaceID</param>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceQuery(System.IntPtr,System.IntPtr)">
            <summary>
            Return 1 if the given geom is in the given space, or return 0 if it is not.
            </summary>
            <returns>An int</returns>
            <param name="space">A  dSpaceID</param>
            <param name="geom">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceClean(System.IntPtr)">
            <summary>
            Method dSpaceClean
            Not sure what this does exactly - no documentation.
            TODO: Find out what this function does and document it here.
            </summary>
            <param name="space">A  dSpaceID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceGetNumGeoms(System.IntPtr)">
            <summary>
            Return the number of geoms contained within a space.
            </summary>
            <returns>An int</returns>
            <param name="space">A  dSpaceID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dSpaceGetGeom(System.IntPtr,System.Int32)">
            <summary>
            Return the i'th geom contained within the space. 
            
            i must range from 0 to dSpaceGetNumGeoms()-1.
            
            If any change is made to the space (including adding and deleting geoms) 
            then no guarantee can be made about how the index number of any 
            particular geom will change. Thus no space changes should be made while 
            enumerating the geoms.
            This function is guaranteed to be fastest when the geoms are accessed in 
            the order 0,1,2,etc. Other non-sequential orders may result in slower 
            access, depending on the internal implementation.
            </summary>
            <returns>A dGeomID</returns>
            <param name="space">A  dSpaceID</param>
            <param name="i">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataCreate">
            <summary>
            Create a dTriMeshData object which is used to store mesh data.
            </summary>
            <returns>A dTriMeshDataID</returns>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataDestroy(System.IntPtr)">
            <summary>
            Destroy a dTriMeshData object.
            </summary>
            <param name="g">A  dTriMeshDataID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataSet(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            In order to efficiently resolve collisions, dCollideTTL needs the 
            positions of the colliding trimeshes in the previous timestep. This is 
            used to calculate an estimated velocity of each colliding triangle, which 
            is used to find the direction of impact, contact normals, etc. This 
            requires the user to update these variables at every timestep. This update 
            is performed outside of ODE, so it is not included in ODE itself. 
            The code to do this looks something like this: 
            	const double *DoubleArrayPtr =
            		Bodies[BodyIndex].TransformationMatrix->GetArray();
            	dGeomTriMeshDataSet( TriMeshData,
            		TRIMESH_LAST_TRANSFORMATION,
            		(void *) DoubleArrayPtr );
            
            The transformation matrix is the standard 4x4 homogeneous transform matrix, 
            and the "DoubleArray" is the standard flattened array of the 16 matrix values.
            </summary>
            <remarks>
            Not really used or documented in the ODE 0.5 code that I have other than the 
            description above.  This looks like part of work in progress, since the 
            Trimesh stuff is still in development.  
            
            I leave this here for completeness, but this function should probably only be
            uses if you know what you are doing.
            </remarks>
            <param name="g">A  dTriMeshDataID</param>
            <param name="data_id">An int</param>
            <param name="data">An IntPtr</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataBuildSingle(System.IntPtr,Tao.Ode.Ode.dVector3[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Build Trimesh data with single precision used in vertex data.
            </summary>
            <remarks>
            Applies to all the dGeomTriMeshDataBuild single and double versions.
            
            (From http://ode.org/ode-latest-userguide.html#sec_10_7_6)
            
            Used for filling a dTriMeshData object with data.
             
            No data is copied here, so the pointers passed into this function must 
            remain valid. 
            This is how the strided data works:
            	struct StridedVertex {
            		dVector3 Vertex;  // 4th component can be left out, reducing memory usage
            		// Userdata
            	};
            	int VertexStride = sizeof (StridedVertex);
                        	struct StridedTri {
            		int Indices[3];
            		// Userdata
            	};
            	int TriStride = sizeof (StridedTri);
            
            The Normals argument is optional: the normals of the faces of each 
            trimesh object. For example,
            	dTriMeshDataID TriMeshData;
            	TriMeshData = dGeomTriMeshGetTriMeshDataID (
            		Bodies[BodyIndex].GeomID);
                        	// as long as dReal == floats
            	dGeomTriMeshDataBuildSingle (TriMeshData,
            		// Vertices
            		Bodies[BodyIndex].VertexPositions,
            		3*sizeof(dReal), (int) numVertices,
            		// Faces
            		Bodies[BodyIndex].TriangleIndices,
            		(int) NumTriangles, 3*sizeof(unsigned int),
            		// Normals
            		Bodies[BodyIndex].FaceNormals);
            
            This pre-calculation saves some time during evaluation of the contacts, 
            but isn't necessary. If you don't want to calculate the face normals 
            before construction (or if you have enormous trimeshes and know that 
            only very few faces will be touching and want to save time), just pass 
            a "NULL" for the Normals argument, and dCollideTTL will take care of the 
            normal calculations itself.
            </remarks>
            <param name="g">A  dTriMeshDataID</param>
            <param name="Vertices">A  dVector3[]</param>
            <param name="VertexStride">An int</param>
            <param name="VertexCount">An int</param>
            <param name="Indices">An int[]</param>
            <param name="IndexCount">An int</param>
            <param name="TriStride">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataBuildSingle1(System.IntPtr,Tao.Ode.Ode.dVector3[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,Tao.Ode.Ode.dVector3[])">
            <summary>
            Build Trimesh data with single precision used in vertex data.
            This function takes a normals array which is used as a trimesh-trimesh
            optimization.
            </summary>
            <param name="g">A  dTriMeshDataID</param>
            <param name="Vertices">A  dVector3[]</param>
            <param name="VertexStride">An int</param>
            <param name="VertexCount">An int</param>
            <param name="Indices">An int[]</param>
            <param name="IndexCount">An int</param>
            <param name="TriStride">An int</param>
            <param name="Normals">A  dVector3[]</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataBuildDouble(System.IntPtr,Tao.Ode.Ode.dVector3,System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Build Trimesh data with double precision used in vertex data.
            </summary>
            <param name="g">A  dTriMeshDataID</param>
            <param name="Vertices">A  dVector3</param>
            <param name="VertexStride">An int</param>
            <param name="VertexCount">An int</param>
            <param name="Indices">An int[]</param>
            <param name="IndexCount">An int</param>
            <param name="TriStride">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataBuildDouble1(System.IntPtr,Tao.Ode.Ode.dVector3[],System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32,Tao.Ode.Ode.dVector3[])">
            <summary>
            Build Trimesh data with double precision used in vertex data.
            This function takes a normals array which is used as a trimesh-trimesh
            optimization.
            </summary>
            <param name="g">A  dTriMeshDataID</param>
            <param name="Vertices">A  dVector3[]</param>
            <param name="VertexStride">An int</param>
            <param name="VertexCount">An int</param>
            <param name="Indices">An int[]</param>
            <param name="IndexCount">An int</param>
            <param name="TriStride">An int</param>
            <param name="Normals">A  dVector3[]</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataBuildSimple(System.IntPtr,Tao.Ode.Ode.dVector3[],System.Int32,System.Int32[],System.Int32)">
            <summary>
            Simple trimesh build function provided for convenience.
            
            Uses single/double precision vertices and normals depending on the
            current value of the dReal alias.
            The precision to use depends on which version of the ODE library is being
            used - single or double precision.  Depends on whether dSINGLE or dDOUBLE is
            defined during ODE compilation.
            </summary>
            <param name="g">A  dTriMeshDataID</param>
            <param name="Vertices">A  dVector3[]</param>
            <param name="VertexCount">An int</param>
            <param name="Indices">An int[]</param>
            <param name="IndexCount">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshDataBuildSimple1(System.IntPtr,Tao.Ode.Ode.dVector3[],System.Int32,System.Int32[],System.Int32,Tao.Ode.Ode.dVector3[])">
            <summary>
            Simple trimesh build function provided for convenience.
            This version takes a normals array to use for trimesh-trimesh optimization.
            
            Uses single/double precision vertices and normals depending on the
            current value of the dReal alias.
            The precision to use depends on which version of the ODE library is being
            used - single or double precision.  Depends on whether dSINGLE or dDOUBLE is
            defined during ODE compilation.
            </summary>
            <param name="g">A  dTriMeshDataID</param>
            <param name="Vertices">A  dVector3[]</param>
            <param name="VertexCount">An int</param>
            <param name="Indices">An int[]</param>
            <param name="IndexCount">An int</param>
            <param name="Normals">A  dVector3[]</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshSetCallback(System.IntPtr,Tao.Ode.Ode.dTriCallback)">
            <summary>
            Set per triangle callback for specified trimesh.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="Callback">A  dTriCallback</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshGetCallback(System.IntPtr)">
            <summary>
            Get per triangle callback for specified trimesh.
            </summary>
            <returns>A dTriCallback</returns>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshSetArrayCallback(System.IntPtr,Tao.Ode.Ode.dTriArrayCallback)">
            <summary>
            Set per object callback for specified trimesh.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="ArrayCallback">A  dTriArrayCallback</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshGetArrayCallback(System.IntPtr)">
            <summary>
            Get per object callback for specified trimesh
            </summary>
            <returns>A dTriArrayCallback</returns>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshSetRayCallback(System.IntPtr,Tao.Ode.Ode.dTriRayCallback)">
            <summary>
            Set ray callback for specified trimesh.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="Callback">A  dTriRayCallback</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshGetRayCallback(System.IntPtr)">
            <summary>
            Get ray callback for specified trimesh.
            </summary>
            <returns>A dTriRayCallback</returns>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dCreateTriMesh(System.IntPtr,System.IntPtr,Tao.Ode.Ode.dTriCallback,Tao.Ode.Ode.dTriArrayCallback,Tao.Ode.Ode.dTriRayCallback)">
            <summary>
            Trimesh class constructor.
            
            The Data member defines the vertex data the newly created triangle mesh will use.
            
            Callbacks are optional.
            </summary>
            <returns>A dGeomID</returns>
            <param name="space">A  dSpaceID</param>
            <param name="Data">A  dTriMeshDataID</param>
            <param name="Callback">A  dTriCallback</param>
            <param name="ArrayCallback">A  dTriArrayCallback</param>
            <param name="RayCallback">A  dTriRayCallback</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshSetData(System.IntPtr,System.IntPtr)">
            <summary>
            Replaces the current vertex data.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="Data">A  dTriMeshDataID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshEnableTC(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Enable/disable the use of temporal coherence during tri-mesh collision checks. 
            Temporal coherence can be enabled/disabled per tri-mesh instance/geom class pair, 
            currently it works for spheres and boxes. The default for spheres and boxes is 'false'.
            The 'enable' param should be 1 for true, 0 for false.
            Temporal coherence is optional because allowing it can cause subtle efficiency problems
            in situations where a tri-mesh may collide with many different geoms during its lifespan. 
            If you enable temporal coherence on a tri-mesh then these problems can be eased by 
            intermittently calling dGeomTriMeshClearTCCache for it.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="geomClass">An int</param>
            <param name="enable">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshIsTCEnabled(System.IntPtr,System.Int32)">
            <summary>
            Checks whether the use of temporal coherence during tri-mesh collision checks is enabled.
            
            Returns 1 if enabled, 0 if not enabled.
            </summary>
            <returns>An int</returns>
            <param name="g">A  dGeomID</param>
            <param name="geomClass">An int</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshClearTCCache(System.IntPtr)">
            <summary>
            Clears the internal temporal coherence caches. When a geom has its
            collision checked with a trimesh once, data is stored inside the trimesh.
            With large worlds with lots of seperate objects this list could get huge.
            </summary>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshGetTriMeshDataID(System.IntPtr)">
            <summary>
            Returns the TriMeshDataID for the specified geom.
            </summary>
            <returns>A dTriMeshDataID</returns>
            <param name="g">A  dGeomID</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshGetTriangle(System.IntPtr,System.Int32,Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dVector3@,Tao.Ode.Ode.dVector3@)">
            <summary>
            Retrieves a triangle in object space. The v0, v1 and v2 arguments are optional.
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="Index">An int</param>
            <param name="v0">A  dVector3</param>
            <param name="v1">A  dVector3</param>
            <param name="v2">A  dVector3</param>
        </member>
        <member name="M:Tao.Ode.Ode.dGeomTriMeshGetPoint(System.IntPtr,System.Int32,System.Single,System.Single,Tao.Ode.Ode.dVector3@)">
            <summary>
            Retrieves a position on the requested triangle and the given
            barycentric coordinates
            </summary>
            <param name="g">A  dGeomID</param>
            <param name="Index">An int</param>
            <param name="u">A  dReal</param>
            <param name="v">A  dReal</param>
            <param name="Out">A  dVector3</param>
        </member>
        <member name="T:Tao.Ode.Ode.dClassNumbers">
            <summary>
            class numbers - each geometry object needs a unique number 
            </summary>
        </member>
        <member name="T:Tao.Ode.Ode.dMass">
            <summary>
            Describes the mass parameters of a rigid body
            </summary>
            <remarks>
            mass - the total mass of the rigid body
            c - center of gravity position in body frame (x,y,z)
            I - 3x3 inertia tensor in body frame, about POR
            </remarks>
        </member>
        <member name="T:Tao.Ode.Ode.dContactGeom">
            <summary>
            Contact info set by collision functions
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dContactGeom.pos">
            <summary>
            The contact position in global coordinates.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dContactGeom.normal">
            <summary>
            A unit length vector that is, generally speaking, perpendicular to the contact surface.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dContactGeom.depth">
            <summary>
            The depth to which the two bodies inter-penetrate each other. 
            If the depth is zero then the two bodies have a grazing contact, 
            i.e. they "only just" touch. However, this is rare - the simulation is 
            not perfectly accurate and will often step the bodies too far so that 
            the depth is nonzero.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dContactGeom.g1">
            <summary>
            The geometry objects that collided.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dContactGeom.g2">
            <summary>
            The geometry objects that collided.
            </summary>
        </member>
        <member name="T:Tao.Ode.Ode.dSurfaceParameters">
            <summary>
            Defines the properties of the colliding surfaces
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.mode">
            <summary>
            Contact flags. This must always be set. This is a combination of one or more of the following flags:
                        dContactMu2			If not set, use mu for both friction directions. 
            					If set, use mu for friction direction 1, use mu2 for friction direction 2.
            dContactFDir1		If set, take fdir1 as friction direction 1, otherwise automatically compute 
            					friction direction 1 to be perpendicular to the contact normal (in which 
            					case its resulting orientation is unpredictable).
            dContactBounce		If set, the contact surface is bouncy, in other words the bodies will 
            					bounce off each other. The exact amount of bouncyness is controlled by 
            					the bounce parameter.
            dContactSoftERP		If set, the error reduction parameter of the contact normal can be set 
            					with the soft_erp parameter. This is useful to make surfaces soft.
            dContactSoftCFM		If set, the constraint force mixing parameter of the contact normal 
            					can be set with the soft_cfm parameter. This is useful to make surfaces soft.
            dContactMotion1		If set, the contact surface is assumed to be moving independently of the 
            					motion of the bodies. This is kind of like a conveyor belt running over 
            					the surface. When this flag is set, motion1 defines the surface velocity 
            					in friction direction 1.
            dContactMotion2		The same thing as above, but for friction direction 2.
            dContactSlip1		Force-dependent-slip (FDS) in friction direction 1.
            dContactSlip2		Force-dependent-slip (FDS) in friction direction 2.
            dContactApprox1_1	Use the friction pyramid approximation for friction direction 1. If this is 
            					not specified then the constant-force-limit approximation is used (and mu is 
            					a force limit).
            dContactApprox1_2	Use the friction pyramid approximation for friction direction 2. If this is 
            					not specified then the constant-force-limit approximation is used (and mu is 
            					a force limit).
            dContactApprox1		Equivalent to both dContactApprox1_1 and dContactApprox1_2.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.mu">
            <summary>
            Coulomb friction coefficient. 
            This must be in the range 0 to dInfinity. 
            0 results in a frictionless contact, and dInfinity results in a contact that never slips. 
            Note that frictionless contacts are less time consuming to compute than ones with friction, 
            and infinite friction contacts can be cheaper than contacts with finite friction. 
            
            This must always be set.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.mu2">
            <summary>
            Optional Coulomb friction coefficient for friction direction 2 (0..dInfinity). 
            
            This is only set if the corresponding flag is set in mode.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.bounce">
            <summary>
            Restitution parameter (0..1). 
            0 means the surfaces are not bouncy at all, 1 is maximum bouncyness. 
            
            This is only set if the corresponding flag is set in mode.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.bounce_vel">
            <summary>
            Restitution parameter (0..1). 
            0 means the surfaces are not bouncy at all, 1 is maximum bouncyness. 
            
            This is only set if the corresponding flag is set in mode.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.soft_erp">
            <summary>
            Contact normal ``softness'' parameter. 
            
            This is only set if the corresponding flag is set in mode.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.soft_cfm">
            <summary>
            Contact normal ``softness'' parameter. 
            
            This is only set if the corresponding flag is set in mode.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.motion1">
            <summary>
            Surface velocity in friction directions 1 (in m/s). 
            
            Only set if the corresponding flags are set in mode.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.motion2">
            <summary>
            Surface velocity in friction directions 1 (in m/s). 
            
            Only set if the corresponding flags are set in mode.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.slip1">
            <summary>
            The coefficients of force-dependent-slip (FDS) for friction directions 1 and 2. 
            
            These are only set if the corresponding flags are set in mode.
            
            FDS is an effect that causes the contacting surfaces to side past each other with a 
            velocity that is proportional to the force that is being applied tangentially to that surface.
            
            Consider a contact point where the coefficient of friction mu is infinite. Normally, if a 
            force f is applied to the two contacting surfaces, to try and get them to slide past each 
            other, they will not move. However, if the FDS coefficient is set to a positive value k 
            then the surfaces will slide past each other, building up to a steady velocity of k*f 
            relative to each other.
            
            Note that this is quite different from normal frictional effects: the force does not 
            cause a constant acceleration of the surfaces relative to each other - it causes a 
            brief acceleration to achieve the steady velocity.
            
            This is useful for modeling some situations, in particular tires. For example consider 
            a car at rest on a road. Pushing the car in its direction of travel will cause it to 
            start moving (i.e. the tires will start rolling). Pushing the car in the perpendicular 
            direction will have no effect, as the tires do not roll in that direction. However - if 
            the car is moving at a velocity v, applying a force f in the perpendicular direction will 
            cause the tires to slip on the road with a velocity proportional to f*v (Yes, this really 
            happens).
                        To model this in ODE set the tire-road contact parameters as follows: set friction direction 1 
            in the direction that the tire is rolling in, and set the FDS slip coefficient in friction 
            direction 2 to k*v, where v is the tire rolling velocity and k is a tire parameter that you can 
            choose based on experimentation.
            
            Note that FDS is quite separate from the sticking/slipping effects of Coulomb friction - both 
            modes can be used together at a single contact point. 
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dSurfaceParameters.slip2">
            <summary>
            The coefficients of force-dependent-slip (FDS) for friction directions 1 and 2. 
            
            These are only set if the corresponding flags are set in mode.
            
            FDS is an effect that causes the contacting surfaces to side past each other with a 
            velocity that is proportional to the force that is being applied tangentially to that surface.
            
            Consider a contact point where the coefficient of friction mu is infinite. Normally, if a 
            force f is applied to the two contacting surfaces, to try and get them to slide past each 
            other, they will not move. However, if the FDS coefficient is set to a positive value k 
            then the surfaces will slide past each other, building up to a steady velocity of k*f 
            relative to each other.
            
            Note that this is quite different from normal frictional effects: the force does not 
            cause a constant acceleration of the surfaces relative to each other - it causes a 
            brief acceleration to achieve the steady velocity.
            
            This is useful for modeling some situations, in particular tires. For example consider 
            a car at rest on a road. Pushing the car in its direction of travel will cause it to 
            start moving (i.e. the tires will start rolling). Pushing the car in the perpendicular 
            direction will have no effect, as the tires do not roll in that direction. However - if 
            the car is moving at a velocity v, applying a force f in the perpendicular direction will 
            cause the tires to slip on the road with a velocity proportional to f*v (Yes, this really 
            happens).
                        To model this in ODE set the tire-road contact parameters as follows: set friction direction 1 
            in the direction that the tire is rolling in, and set the FDS slip coefficient in friction 
            direction 2 to k*v, where v is the tire rolling velocity and k is a tire parameter that you can 
            choose based on experimentation.
            
            Note that FDS is quite separate from the sticking/slipping effects of Coulomb friction - both 
            modes can be used together at a single contact point. 
            </summary>
        </member>
        <member name="T:Tao.Ode.Ode.dContact">
            <summary>
            Contact structure used by contact joint
            </summary>
        </member>
        <member name="T:Tao.Ode.Ode.dJointFeedback">
            <summary>
            During the world time step, the forces that are applied by each joint are computed. 
            These forces are added directly to the joined bodies, and the user normally has no 
            way of telling which joint contributed how much force.
                        If this information is desired then the user can allocate a dJointFeedback structure 
            and pass its pointer to the dJointSetFeedback() function. 
            
            The feedback information structure is defined as follows:
            
            typedef struct dJointFeedback {
            	dVector3 f1;       // force that joint applies to body 1
            	dVector3 t1;       // torque that joint applies to body 1
            	dVector3 f2;       // force that joint applies to body 2
            	dVector3 t2;       // torque that joint applies to body 2
            } dJointFeedback;
            
            During the time step any feedback structures that are attached to joints will be filled in with the 
            joint's force and torque information. The dJointGetFeedback() function returns the current feedback 
            structure pointer, or 0 if none is used (this is the default). dJointSetFeedback() can be passed 0 
            to disable feedback for that joint.
            
            Now for some API design notes. It might seem strange to require that users perform the allocation 
            of these structures. Why not just store the data statically in each joint? The reason is that not 
            all users will use the feedback information, and even when it is used not all joints will need it. 
            It will waste memory to store it statically, especially as this structure could grow to store a 
            lot of extra information in the future.
            
            Why not have ODE allocate the structure itself, at the user's request? The reason is that contact 
            joints (which are created and destroyed every time step) would require a lot of time to be spent 
            in memory allocation if feedback is required. Letting the user do the allocation means that a 
            better allocation strategy can be provided, e.g simply allocating them out of a fixed array.
            
            The alternative to this API is to have a joint-force callback. This would work of course, but 
            it has a few problems. First, callbacks tend to pollute APIs and sometimes require the user 
            to go through unnatural contortions to get the data to the right place. Second, this would 
            expose ODE to being changed in the middle of a step (which would have bad consequences), and 
            there would have to be some kind of guard against this or a debugging check for it - which 
            would complicate things.
            </summary>
        </member>
        <member name="F:Tao.Ode.Ode.dJointFeedback.f1">
            <summary>Force applied to body 1</summary>
        </member>
        <member name="F:Tao.Ode.Ode.dJointFeedback.t1">
            <summary>Torque applied to body 1</summary>
        </member>
        <member name="F:Tao.Ode.Ode.dJointFeedback.f2">
            <summary>Force applied to body 2</summary>
        </member>
        <member name="F:Tao.Ode.Ode.dJointFeedback.t2">
            <summary>Torque applied to body 2</summary>
        </member>
        <member name="T:Tao.Ode.Ode.dNearCallback">
            <summary>
            Callback function for dSpaceCollide and dSpaceCollide2
            </summary>
        </member>
        <member name="T:Tao.Ode.Ode.dTriCallback">
            <summary>
            Per triangle callback.
            Allows user to state if a collision with a particular triangle is wanted
            If the return value is zero no contact will be generated.
            </summary>
        </member>
        <member name="T:Tao.Ode.Ode.dTriArrayCallback">
            <summary>
            Per object callback.
            Allows user to get the list of all intersecting triangles in one shot.
            </summary>
        </member>
        <member name="T:Tao.Ode.Ode.dTriRayCallback">
            <summary>
            Ray callback. 
            Allows the user to determine if a ray collides with a triangle based on 
            the barycentric coordinates of an intersection. The user can for example 
            sample a bitmap to determine if a collision should occur.
            </summary>
        </member>
    </members>
</doc>
